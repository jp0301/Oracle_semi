/*
================================================================================
                  ■■■■■■   테이블  ■■■■■■
================================================================================
*/
CREATE TABLE TBL_ADMIN (
	ADMIN_CODE	VARCHAR2(10)	NOT NULL,
	ADMIN_PW	VARCHAR2(7)	NULL
);

CREATE TABLE TBL_PROF (
	PROF_CODE	VARCHAR2(10)	NOT NULL,
	PROF_PW	VARCHAR2(7)	NULL,
	PROF_NAME	VARCHAR2(10)	NULL,
	PROF_RRN	VARCHAR2(14)	NULL,
	PROF_TEL	VARCHAR2(13)	NULL
);

CREATE TABLE TBL_STD (
	STD_NUMBER	VARCHAR2(10)	NOT NULL,
	STD_NAME	VARCHAR2(10)	NULL,
	STD_PW	VARCHAR2(7)	NULL,
	STD_RRN	VARCHAR2(14)	NULL
);

CREATE TABLE TBL_OPENCOU (
	OPENCOU_CODE	VARCHAR2(10)	NOT NULL,
	COURSE_CODE	VARCHAR2(10)	NOT NULL,
	CLASS_CODE	VARCHAR2(10)	NOT NULL,
	OPENCOU_START	DATE	NULL,
	OPENCOU_END	DATE	NULL
);

CREATE TABLE TBL_SUGANG (
	SUGANG_CODE	VARCHAR2(10)	NOT NULL,
	OPENCOU_CODE	VARCHAR2(10)	NOT NULL,
	STD_NUMBER	VARCHAR2(10)	NOT NULL,
	SUGANG_DATE	DATE	NULL
);

CREATE TABLE TBL_SCO (
	SCO_CODE	VARCHAR2(10)	NOT NULL,
	OPENSUB_CODE	VARCHAR2(10)	NOT NULL,
	SUGANG_CODE	VARCHAR2(10)	NOT NULL,
	SCO_ATTEND	NUMBER(3)	NULL,
	SCO_WRITE	NUMBER(3)	NULL,
	SCO_PRAC	NUMBER(3)	NULL
);

CREATE TABLE TBL_BOOK (
	BOOK_CODE	VARCHAR2(10)	NOT NULL,
	BOOK_NAME	VARCHAR2(20)	NULL,
	BOOK_AUTHOR	VARCHAR2(20)	NULL
);

CREATE TABLE TBL_CLASS (
	CLASS_CODE	VARCHAR2(10)	NOT NULL,
	CLASS_NAME	VARCHAR2(20)	NULL
);

CREATE TABLE TBL_SUB (
	SUB_CODE	VARCHAR2(10)	NOT NULL,
	SUB_NAME	VARCHAR2(20)	NULL
);

CREATE TABLE TBL_COURSE (
	COURSE_CODE	VARCHAR2(10)	NOT NULL,
	COURSE_NAME	VARCHAR2(100)	NULL
);

CREATE TABLE TBL_OPENSUB (
	OPENSUB_CODE	VARCHAR2(10)	NOT NULL,
	OPENCOU_CODE	VARCHAR2(10)	NOT NULL,
	PROF_CODE	VARCHAR2(10)	NOT NULL,
	SUB_CODE	VARCHAR2(10)	NOT NULL,
	BOOK_CODE	VARCHAR2(10)	NOT NULL,
	OPENSUB_DATE	DATE	NULL,
	OPENSUB_END	DATE	NULL,
	OPENSUB_ATTEND	NUMBER(2)	NULL,
	OPENSUB_WRITE	NUMBER(2)	NULL,
	OPENSUB_PRAC	NUMBER(2)	NULL
);

CREATE TABLE TBL_OUT (
	OUT_CODE	VARCHAR2(10)	NOT NULL,
	SUGANG_CODE	VARCHAR2(10)	NOT NULL,
	OUT_REASON_CODE	VARCHAR2(10)	NOT NULL,
	OUT_DATE	DATE	NULL
);

CREATE TABLE TBL_OUT_REASON (
	OUT_REASON_CODE	VARCHAR2(10)	NOT NULL,
	OUT_REASON	VARCHAR2(40)	NULL
);

ALTER TABLE TBL_ADMIN ADD CONSTRAINT PK_TBL_ADMIN PRIMARY KEY (
	ADMIN_CODE
);

ALTER TABLE TBL_PROF ADD CONSTRAINT PK_TBL_PROF PRIMARY KEY (
	PROF_CODE
);

ALTER TABLE TBL_STD ADD CONSTRAINT PK_TBL_STD PRIMARY KEY (
	STD_NUMBER
);

ALTER TABLE TBL_OPENCOU ADD CONSTRAINT PK_TBL_OPENCOU PRIMARY KEY (
	OPENCOU_CODE
);

ALTER TABLE TBL_SUGANG ADD CONSTRAINT PK_TBL_SUGANG PRIMARY KEY (
	SUGANG_CODE
);

ALTER TABLE TBL_SCO ADD CONSTRAINT PK_TBL_SCO PRIMARY KEY (
	SCO_CODE
);

ALTER TABLE TBL_BOOK ADD CONSTRAINT PK_TBL_BOOK PRIMARY KEY (
	BOOK_CODE
);

ALTER TABLE TBL_CLASS ADD CONSTRAINT PK_TBL_CLASS PRIMARY KEY (
	CLASS_CODE
);

ALTER TABLE TBL_SUB ADD CONSTRAINT PK_TBL_SUB PRIMARY KEY (
	SUB_CODE
);

ALTER TABLE TBL_COURSE ADD CONSTRAINT PK_TBL_COURSE PRIMARY KEY (
	COURSE_CODE
);

ALTER TABLE TBL_OPENSUB ADD CONSTRAINT PK_TBL_OPENSUB PRIMARY KEY (
	OPENSUB_CODE
);

ALTER TABLE TBL_OUT ADD CONSTRAINT PK_TBL_OUT PRIMARY KEY (
	OUT_CODE
);

ALTER TABLE TBL_OUT_REASON ADD CONSTRAINT PK_TBL_OUT_REASON PRIMARY KEY (
	OUT_REASON_CODE
);

ALTER TABLE TBL_OPENCOU ADD CONSTRAINT FK_TBL_COURSE_TO_TBL_OPENCOU_1 FOREIGN KEY (
	COURSE_CODE
)
REFERENCES TBL_COURSE (
	COURSE_CODE
);

ALTER TABLE TBL_OPENCOU ADD CONSTRAINT FK_TBL_CLASS_TO_TBL_OPENCOU_1 FOREIGN KEY (
	CLASS_CODE
)
REFERENCES TBL_CLASS (
	CLASS_CODE
);

ALTER TABLE TBL_SUGANG ADD CONSTRAINT FK_TBL_OPENCOU_TO_TBL_SUGANG_1 FOREIGN KEY (
	OPENCOU_CODE
)
REFERENCES TBL_OPENCOU (
	OPENCOU_CODE
);

ALTER TABLE TBL_SUGANG ADD CONSTRAINT FK_TBL_STD_TO_TBL_SUGANG_1 FOREIGN KEY (
	STD_NUMBER
)
REFERENCES TBL_STD (
	STD_NUMBER
);

ALTER TABLE TBL_SCO ADD CONSTRAINT FK_TBL_OPENSUB_TO_TBL_SCO_1 FOREIGN KEY (
	OPENSUB_CODE
)
REFERENCES TBL_OPENSUB (
	OPENSUB_CODE
);

ALTER TABLE TBL_SCO ADD CONSTRAINT FK_TBL_SUGANG_TO_TBL_SCO_1 FOREIGN KEY (
	SUGANG_CODE
)
REFERENCES TBL_SUGANG (
	SUGANG_CODE
);

ALTER TABLE TBL_OPENSUB ADD CONSTRAINT OPENSUB_OPENCOU_CODE_FK FOREIGN KEY (
	OPENCOU_CODE
)
REFERENCES TBL_OPENCOU (
	OPENCOU_CODE
);

ALTER TABLE TBL_OPENSUB ADD CONSTRAINT FK_TBL_PROF_TO_TBL_OPENSUB_1 FOREIGN KEY (
	PROF_CODE
)
REFERENCES TBL_PROF (
	PROF_CODE
);

ALTER TABLE TBL_OPENSUB ADD CONSTRAINT FK_TBL_SUB_TO_TBL_OPENSUB_1 FOREIGN KEY (
	SUB_CODE
)
REFERENCES TBL_SUB (
	SUB_CODE
);

ALTER TABLE TBL_OPENSUB ADD CONSTRAINT FK_TBL_BOOK_TO_TBL_OPENSUB_1 FOREIGN KEY (
	BOOK_CODE
)
REFERENCES TBL_BOOK (
	BOOK_CODE
);

ALTER TABLE TBL_OUT ADD CONSTRAINT FK_TBL_SUGANG_TO_TBL_OUT_1 FOREIGN KEY (
	SUGANG_CODE
)
REFERENCES TBL_SUGANG (
	SUGANG_CODE
);

ALTER TABLE TBL_OUT ADD CONSTRAINT FK_TBL_OUT_REASON_TO_TBL_OUT_1 FOREIGN KEY (
	OUT_REASON_CODE
)
REFERENCES TBL_OUT_REASON (
	OUT_REASON_CODE
);

ALTER TABLE TBL_OPENCOU
ADD CONSTRAINT OPENCOU_END_CK CHECK(OPENCOU_END > OPENCOU_START);



/*
================================================================================
                  ■■■■■■   프로시저   ■■■■■■
================================================================================
*/

--○ 관리자
-- PRC_ADM_LOGIN		(관리자 로그인)
create or replace PROCEDURE PRC_ADM_LOGIN 
(LOGIN_PW IN TBL_ADMIN.ADMIN_PW%TYPE)   
IS
    V_ADMIN_CODE TBL_ADMIN.ADMIN_CODE%TYPE;
    V_FLAG NUMBER := 1;
    USER_DEFINE_ERROR1 EXCEPTION;

BEGIN

    SELECT COUNT(*) INTO V_FLAG
    FROM TBL_ADMIN
    WHERE LOGIN_PW = ADMIN_PW;

    IF (V_FLAG = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    SELECT ADMIN_CODE INTO V_ADMIN_CODE
    FROM TBL_ADMIN
    WHERE LOGIN_PW = ADMIN_PW;

    DBMS_OUTPUT.PUT_LINE(V_ADMIN_CODE || ' 관리자 로그인 완료');

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20201,'로그인에 실패했습니다. 패스워드를 다시 입력하세요');
        ROLLBACK;

    COMMIT;

END;






-- PRC_ADMIN_DELETE		(관리자 삭제)
create or replace PROCEDURE PRC_ADMIN_DELETE
( V_ADMIN_PW   IN TBL_ADMIN.ADMIN_PW%TYPE)
IS
    V_FLAG NUMBER := 1;
    V_ADMIN_CODE TBL_ADMIN.ADMIN_CODE%TYPE;
    USER_DEFINE_ERROR1   EXCEPTION;

BEGIN 
    -- 존재하면 1, 미존재하면 0 관리자코드 조회
    SELECT COUNT(*) INTO V_FLAG
    FROM TBL_ADMIN
    WHERE V_ADMIN_PW = ADMIN_PW;

    IF(V_FLAG = 0)
        THEN RAISE USER_DEFINE_ERROR1; 
    END IF;

    -- 관리자 코드 담기
    SELECT ADMIN_CODE INTO V_ADMIN_CODE
    FROM TBL_ADMIN
    WHERE V_ADMIN_PW = ADMIN_PW;

    -- 관리자 삭제
    DELETE  
    FROM TBL_ADMIN
    WHERE V_ADMIN_PW = ADMIN_PW;

    DBMS_OUTPUT.PUT_LINE(V_ADMIN_CODE || ' 관리자 삭제');

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20203,'해당 관리자가 없습니다.');
            ROLLBACK;

    COMMIT;

END;






-- PRC_ADMIN_INSERT		(관리자 등록)
create or replace PROCEDURE PRC_ADMIN_INSERT
( V_ADMIN_PW IN TBL_ADMIN.ADMIN_PW%TYPE )
IS
    V_ADMIN_CODE TBL_ADMIN.ADMIN_CODE%TYPE;
    V_FLAG NUMBER := 0;
    USER_DEFINE_ERROR1 EXCEPTION;

BEGIN
    -- PW가 있는지 확인
    -- 존재하면 1 
    -- 존재하지 않으면 0
    SELECT COUNT(*) INTO V_FLAG
    FROM TBL_ADMIN
    WHERE V_ADMIN_PW = ADMIN_PW;

    IF(V_FLAG = 1)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    -- 시퀀스 코드 생성
    V_ADMIN_CODE := TO_CHAR(TBL_ADMIN_SEQ.NEXTVAL);
    V_ADMIN_CODE := 'ADM' || LPAD(V_ADMIN_CODE,3,'0');

    INSERT INTO TBL_ADMIN(ADMIN_CODE,ADMIN_PW)
    VALUES(V_ADMIN_CODE, V_ADMIN_PW);

    DBMS_OUTPUT.PUT_LINE('관리자 "' || V_ADMIN_CODE || '"추가되었습니다.');

    EXCEPTION
    WHEN USER_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20202,'해당 비밀번호는 사용할 수 없습니다.');
        ROLLBACK;

    COMMIT;

END;






-- PRC_ADMIN_UPDATE		(관리자 수정)
create or replace PROCEDURE PRC_ADMIN_UPDATE
( V_ADMIN_PW IN TBL_ADMIN.ADMIN_PW%TYPE
, V_ADMIN_NEWPW IN TBL_ADMIN.ADMIN_PW%TYPE)
IS
    V_FLAG NUMBER := 1;
    USER_DEFINE_ERROR1 EXCEPTION;
BEGIN
    -- 기존 비밀번호 존재하는지 확인
    SELECT COUNT(*) INTO V_FLAG
    FROM TBL_ADMIN
    WHERE V_ADMIN_PW = ADMIN_PW;

    IF(V_FLAG = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    -- 없는 경우 예외처리후 UPDATE 가능

    UPDATE TBL_ADMIN
    SET ADMIN_PW = V_ADMIN_NEWPW
    WHERE V_ADMIN_PW = ADMIN_PW;

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20203,'해당 관리자가 없습니다.(비밀번호 불일치)');
            ROLLBACK;
    COMMIT;

END;








--○ 교재
-- PRC_BOOK_DELETE		(교재 삭제)
create or replace PROCEDURE PRC_BOOK_DELETE
( V_BOOK_CODE   IN TBL_BOOK.BOOK_CODE%TYPE
)
IS
    BOOK_CHECK_CODE TBL_BOOK.BOOK_CODE%TYPE;
    USER_DEFINE_ERROR EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;
BEGIN

    -- 교재코드 조회
    SELECT NVL((SELECT BOOK_CODE
                FROM TBL_BOOK
                WHERE BOOK_CODE = V_BOOK_CODE), '0') INTO BOOK_CHECK_CODE
    FROM DUAL;

    -- 조건 판단으로 에러발생, 교재코드가 없으면 예외 발생
    IF (BOOK_CHECK_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR;
    END IF;   

    -- 삭제하려는 교재를 지금 사용중인 과목이 있는지 조회를 한다.
    SELECT NVL((SELECT COUNT(BOOK_CODE)
                FROM TBL_OPENSUB
                WHERE BOOK_CODE = V_BOOK_CODE), '0') INTO BOOK_CHECK_CODE
    FROM DUAL;

    IF (BOOK_CHECK_CODE != '0')
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;

    DELETE
    FROM TBL_BOOK
    WHERE BOOK_CODE = V_BOOK_CODE;
    
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20802, '등록되지 않은 교재코드입니다.');
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20803, '해당 교재를 이미 사용중입니다.');
        ROLLBACK;
    -- 커밋
    COMMIT;
END;





-- PRC_BOOK_INSERT		(교재 등록)
create or replace PROCEDURE PRC_BOOK_INSERT
( V_BOOK_NAME   IN TBL_BOOK.BOOK_NAME%TYPE
, V_BOOK_AUTHOR IN TBL_BOOK.BOOK_AUTHOR%TYPE
)
IS
    BOOK_CHECK_NAME TBL_BOOK.BOOK_NAME%TYPE;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    -- 입력받은 책 이름이 있는지 확인하고 
    -- BOOK_CHECK_NAME에 있으면 입력 받은 이름 그대로 넣고 없으면 0을 넣는다.
    SELECT NVL((SELECT BOOK_NAME 
                FROM TBL_BOOK 
                WHERE BOOK_NAME = V_BOOK_NAME), '0') INTO BOOK_CHECK_NAME
    FROM DUAL;

    -- 조건문으로 BOOK_CHECK_NAME에 책 이름이 들어가있으면 에러 발생
    -- 그게 아니라면 INSERT문 진행으로 넘어간다.
    IF (BOOK_CHECK_NAME != '0')
        THEN RAISE USER_DEFINE_ERROR;
    END IF;

    -- INSERT 쿼리문 수행
    INSERT INTO TBL_BOOK(BOOK_CODE, BOOK_NAME, BOOK_AUTHOR)
    VALUES(('BOK' || LPAD(TO_CHAR(TBL_BOOK_SEQ.NEXTVAL), 3, '0')), V_BOOK_NAME, V_BOOK_AUTHOR);

    -- 예외 처리
    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20801, '이미 등록된 교재입니다.');
            ROLLBACK;
        --WHEN OTHERS
            --THEN ROLLBACK;
    -- 커밋
    COMMIT;
END;





-- PRC_BOOK_UPDATE		(교재 수정)
create or replace PROCEDURE PRC_BOOK_UPDATE
( V_BOOK_CODE   IN TBL_BOOK.BOOK_CODE%TYPE
, V_BOOK_NAME   IN TBL_BOOK.BOOK_NAME%TYPE
, V_BOOK_AUTHOR IN TBL_BOOK.BOOK_AUTHOR%TYPE  
)
IS
    BOOK_CHECK_CODE TBL_BOOK.BOOK_CODE%TYPE;
    BOOK_CHECK_NAME TBL_BOOK.BOOK_NAME%TYPE;
    USER_DEFINE_ERROR EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;
BEGIN
    -- 교재코드가 같은지 판단하기 위한 조회
    SELECT NVL((SELECT BOOK_CODE
                FROM TBL_BOOK
                WHERE BOOK_CODE = V_BOOK_CODE), '0') INTO BOOK_CHECK_CODE
    FROM DUAL;

    -- 조건 판단으로 에러발생
    IF (BOOK_CHECK_CODE != '0')
        THEN RAISE USER_DEFINE_ERROR;
    END IF;

    -- 교재명이 같은지 판단하기 위한 조회
    SELECT NVL((SELECT BOOK_NAME 
                FROM TBL_BOOK 
                WHERE BOOK_NAME = V_BOOK_NAME), '0') INTO BOOK_CHECK_NAME
    FROM DUAL;

    -- 조건 판단으로 에러발생
    IF (BOOK_CHECK_NAME != '0')
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;


    -- 업데이트 쿼리문
    UPDATE TBL_BOOK
    SET BOOK_NAME = V_BOOK_NAME, BOOK_AUTHOR = V_BOOK_AUTHOR
    WHERE BOOK_CODE = V_BOOK_CODE;


    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20802, '등록되지 않은 교재코드입니다.');
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20803, '이미 등록된 교재입니다.');
        ROLLBACK;

    -- 커밋
    COMMIT;
END;








--○ 강의실
-- PRC_CALSS_INSERT		(강의실 등록)
create or replace PROCEDURE PRC_CLASS_INSERT
( V_CLASS_NAME IN TBL_CLASS.CLASS_NAME%TYPE
)

IS
    --필요변수 
    --1.강의장이 있는지 확인할 변수 V_CLASS_CHECK
    --2.사용자 정의 에러
    --CLASS_DEFINE_ERROR1; -20701 '해당 강의실은 존재합니다');

    V_CLASS_CHECK NUMBER(2);
    V_CLASS_CODE TBL_CLASS.CLASS_CODE%TYPE;
    CLASS_DEFINE_ERROR1 EXCEPTION;

BEGIN

    SELECT COUNT(*) INTO V_CLASS_CHECK
    FROM TBL_CLASS
    WHERE CLASS_NAME = V_CLASS_NAME;

    IF(V_CLASS_CHECK != 0)
        THEN RAISE CLASS_DEFINE_ERROR1;
    END IF;

    V_CLASS_CODE := TO_CHAR(SEQ_CLASS.NEXTVAL);
    V_CLASS_CODE := 'CLA' || LPAD(V_CLASS_CODE,3,0);

    INSERT INTO TBL_CLASS(CLASS_CODE, CLASS_NAME)
    VALUES(V_CLASS_CODE, V_CLASS_NAME);

    EXCEPTION
        WHEN CLASS_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20701,'해당강의실은 존재합니다.');
        ROLLBACK;


END;






-- PRC_CLASS_DELETE		(강의실 삭제)
create or replace PROCEDURE PRC_CLASS_DELETE
( V_CLASS_NAME IN TBL_CLASS.CLASS_NAME%TYPE 
)
IS
    --필요변수 
    --1.강의장이 있는지 확인할 변수 V_CLASS_CHECK
    --2.사용자 정의 에러
    --CLASS_DEFINE_ERROR1; -20700 '해당 강의실은 존재하지 않습니다.');

    V_CLASS_CHECK NUMBER(2);

    CLASS_DEFINE_ERROR1 EXCEPTION;


BEGIN

    SELECT COUNT(*) INTO V_CLASS_CHECK
    FROM TBL_CLASS
    WHERE CLASS_NAME = V_CLASS_NAME;

    IF(V_CLASS_CHECK = 0)
        THEN RAISE CLASS_DEFINE_ERROR1;
    END IF;

    DELETE
    FROM TBL_CLASS
    WHERE CLASS_NAME = V_CLASS_NAME;

    EXCEPTION
        WHEN CLASS_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20700,'해당 강의실은 존재하지 않습니다.');

END;






-- PRC_CLASS_UPDATE		(강의실 수정)
create or replace PROCEDURE PRC_CLASS_UPDATE
( V_CLASS_CODE IN TBL_CLASS.CLASS_CODE%TYPE
, V_CLASS_NAME IN TBL_CLASS.CLASS_NAME%TYPE 
)
                                            
IS
    --바꾸려는 강의실명이 존재하는지 확인
    --있다면 해당강의실명이 이미 존재한다는 사용자 정의 에러
    --없다면 그대로 UPDATE
    V_CLASS_CHECK NUMBER(2);

    CLASS_DEFINE_ERROR1 EXCEPTION;  --20701


BEGIN

    SELECT COUNT(*) INTO V_CLASS_CHECK
    FROM TBL_CLASS
    WHERE CLASS_NAME = V_CLASS_NAME;

    IF(V_CLASS_CHECK != 0)
        THEN RAISE CLASS_DEFINE_ERROR1;
    END IF;

    UPDATE TBL_CLASS
    SET CLASS_NAME = V_CLASS_NAME
    WHERE CLASS_CODE = V_CLASS_CODE;


    EXCEPTION
        WHEN CLASS_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20701,'해당강의실은 존재합니다.');

END;







--○ 과정, 개설 과정
-- PRC_COURSE_DELETE		(과정, 개설과정 삭제)
create or replace PROCEDURE PRC_COURSE_DELETE
( V_COURSE_CODE IN TBL_COURSE.COURSE_CODE%TYPE
)

IS

BEGIN

    DELETE
    FROM TBL_COURSE
    WHERE COURSE_CODE = V_COURSE_CODE;

    COMMIT;

END;






-- PRC_COURSE_INSERT		(과정, 개설과정 등록)
create or replace PROCEDURE PRC_COURSE_INSERT
( V_COURSE_NAME   IN TBL_COURSE.COURSE_NAME%TYPE
, V_OPENCOU_START IN TBL_OPENCOU.OPENCOU_START%TYPE
, V_OPENCOU_END IN TBL_OPENCOU.OPENCOU_END%TYPE
, V_CLASS_NAME IN TBL_CLASS.CLASS_NAME%TYPE
)

IS    --INSERT에서 쓸 강의실 개설과정  과정코드들 변수
    V_COURSE_CODE TBL_COURSE.COURSE_CODE%TYPE;
    V_CLASS_CODE TBL_CLASS.CLASS_CODE%TYPE;
    V_OPENCOU_CODE TBL_OPENCOU.OPENCOU_CODE%TYPE;


    --해당 과정명이 이미 과정테이블에 존재한다면
    EXIST_COURSE_NAME VARCHAR2(5);
    EXIST_CLASS_NAME VARCHAR2(5);
    --사용자 정의 에러 2가지  1.해당 강의장이 사용중 2.현재보다 이전날짜의 과정을 입력할수 없음

    DATE_DEFINE_ERROR1  EXCEPTION;
    DATE_DEFINE_ERROR2  EXCEPTION;




    --등록할 과정에 할당된 강의실에 현재 다른 과정이 강의중일때 비교하기 위한 커서
    --입력받은 강의실명에 해당하는 코드를 가져와  개설과정의 과정 종료일들을 가져온다.
    CURSOR CUR_CLASS_CHECK
    IS
    SELECT OPENCOU_END
    FROM TBL_OPENCOU
    WHERE CLASS_CODE IN (SELECT CLASS_CODE FROM TBL_CLASS WHERE CLASS_NAME = V_CLASS_NAME);  

    --커서에 쓰일 과정 종료일 변수

    V_OPENCOU_END_TEMP TBL_OPENCOU.OPENCOU_END%TYPE;



BEGIN
    --강의실 이름이 겹친다면? (날짜 기준으로 만들기)
    OPEN CUR_CLASS_CHECK;                                                --커서 시작

        LOOP

            FETCH CUR_CLASS_CHECK INTO V_OPENCOU_END_TEMP; 

            EXIT WHEN CUR_CLASS_CHECK%NOTFOUND;

               IF(V_OPENCOU_START <=  V_OPENCOU_END_TEMP)
                    THEN RAISE DATE_DEFINE_ERROR1;
               END IF;

        END LOOP;

    CLOSE CUR_CLASS_CHECK;                                              --커서 끝



    --등록과정이 현재 날짜보다 전이라면 
    -- 안되게 하기 

    IF(V_OPENCOU_START < SYSDATE)
        THEN RAISE DATE_DEFINE_ERROR2;
    END IF;

    --개설과정코드 생성    
    V_OPENCOU_CODE := TO_CHAR(SEQ_OPENCOU.NEXTVAL);
    V_OPENCOU_CODE := 'OPC' || LPAD(V_OPENCOU_CODE,3,0);

    --TBL_과정에 과정명 입력 그리고 코드 자동 입력, 이러면 과정코드는 같은 과정이어도 절대 같을 수없다.
                                                 --그러므로 원래 과정에 있는지 판단하고 해당과정이 있다면 --해당 값을 가져와 V_COURSE_CODE에 담고
                                                --INSERT문을 넘기는게 맞다.
    SELECT CASE WHEN EXISTS(SELECT 1 FROM TBL_COURSE WHERE COURSE_NAME = V_COURSE_NAME) THEN '1'
                ELSE '0'
                END
                INTO EXIST_COURSE_NAME
                FROM DUAL;


    IF (EXIST_COURSE_NAME = '1')
      THEN SELECT COURSE_CODE INTO V_COURSE_CODE
           FROM TBL_COURSE
           WHERE COURSE_NAME = V_COURSE_NAME;
      ELSE
           --과정코드 생성
            V_COURSE_CODE := TO_CHAR(SEQ_COURSE.NEXTVAL);
            V_COURSE_CODE := 'COU' || LPAD(V_COURSE_CODE,3,0);
            INSERT INTO TBL_COURSE(COURSE_CODE, COURSE_NAME)
            VALUES(V_COURSE_CODE, V_COURSE_NAME);
    END IF;


 --강의실이 이미 존재하는 경우 해당 강의실 코드를 갖다 써서 INSERT   

     SELECT CASE WHEN EXISTS(SELECT 1 FROM TBL_CLASS WHERE CLASS_NAME = V_CLASS_NAME) THEN '1'
                ELSE '0'
                END
                INTO EXIST_CLASS_NAME
                FROM DUAL;


     IF (EXIST_CLASS_NAME = '1')
      THEN SELECT CLASS_CODE INTO V_CLASS_CODE
           FROM TBL_CLASS
           WHERE CLASS_NAME = V_CLASS_NAME;
      ELSE
            --없던 강의실 이므로 강의실 코드생성 및 데이터 입력
            V_CLASS_CODE := TO_CHAR(SEQ_CLASS.NEXTVAL);
            V_CLASS_CODE := 'CLA' || LPAD(V_CLASS_CODE,3,0);  
            INSERT INTO TBL_CLASS(CLASS_CODE, CLASS_NAME)
            VALUES(V_CLASS_CODE, V_CLASS_NAME);
    END IF;





    --TBL_개설과정에 과정명 입력 그리고 코드 자동 입력
    INSERT INTO TBL_OPENCOU(OPENCOU_CODE, COURSE_CODE, CLASS_CODE, OPENCOU_START, OPENCOU_END)
    VALUES(V_OPENCOU_CODE, V_COURSE_CODE, V_CLASS_CODE, V_OPENCOU_START, V_OPENCOU_END);


    --예외처리
    EXCEPTION
        WHEN DATE_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20400, '해당 강의장은 현재 강의중입니다.');
            ROLLBACK;
        WHEN DATE_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20401, '현재요일보다 이전의 과정을 개설할수는 없습니다.');



    COMMIT;

END;






-- PRC_COURSE_UPDATE		(과정, 개설과정 수정)
create or replace PROCEDURE PRC_COURSE_UPDATE
( V_OPENCOU_CODE   IN TBL_OPENCOU.OPENCOU_CODE%TYPE
, V_COURSE_CODE    IN TBL_OPENCOU.CLASS_CODE%TYPE
, V_OPENCOU_START  IN TBL_OPENCOU.OPENCOU_START%TYPE
, V_OPENCOU_END    IN TBL_OPENCOU.OPENCOU_END%TYPE
, V_CLASS_NAME     IN TBL_CLASS.CLASS_NAME%TYPE
)

IS
    --필요변수
    --수정할 과정이 있는지 없는지 판단하기 위한 V_COURSE_CHECK
    --기능 4번을 위한 커서 CUR_COURSE
    --커서를 위한 V_COURSE_ENDDAY 변수
    --강의실이 있는지 없는지 핀단하기 위한 V_CLASS_CHECK
    --1,3 번 사용자 정의 에러
    
    
    
    V_COURSE_CHECK NUMBER;
    V_CLASS_CHECK NUMBER;
    V_OPENCOU_END_TEMP TBL_OPENCOU.OPENCOU_END%TYPE;
    V_CLASS_CODE TBL_OPENCOU.CLASS_CODE%TYPE;

    CLASS_DEFINE_ERROR1 EXCEPTION;
    COURSE_DEFINE_ERROR1 EXCEPTION;
    DATE_DEFINE_ERROR1 EXCEPTION; -- -20400
    DATE_DEFINE_ERROR2 EXCEPTION; -- -20401     --현재날짜 보다 이전에 대한 과정 입력이 불가능하게 한거였는데
                                               --만약 이전꺼를 잘못입력해서 수정해야 한다면?.... 애들이랑 얘기해보자



BEGIN

  --필요 기능
  --1.있는 과정코드인지는 확인후 없으면 에러
  -- 있는 과정코드라면 해당 과정으로 바꿈
  --2. 강의실 코드가 있는지 확인후 없으면 에러
  --3. 강의실 코드가 있다면 강의실을 사용중인 과정들의 과정 종료날짜와
  --  사용자가 입력한 과정 시작날짜를 비교
  --4.3번을 지났으면 강의실 코드가 없는경우는 걸러졌으므로
  --  CLASS_CODE담아서 UPDATE수행



    --1.
    SELECT COUNT(*) INTO V_COURSE_CHECK
    FROM TBL_COURSE
    WHERE COURSE_CODE = V_COURSE_CODE;


    IF (V_COURSE_CHECK = 0)
        THEN RAISE COURSE_DEFINE_ERROR1;
    END IF;


    --2. 강의실코드에 따라 강의실 이름도 따라오므로
    -- 강의실 이름으로 비교해도 된다. 
    SELECT COUNT(*) INTO V_CLASS_CHECK
    FROM TBL_CLASS
    WHERE CLASS_NAME = V_CLASS_NAME;


    IF (V_CLASS_CHECK =0)
        THEN RAISE CLASS_DEFINE_ERROR1;

    ELSE
        --3.
        DECLARE
            CURSOR CUR_COURSE_CHECK
            IS
            SELECT OPENCOU_END
            FROM TBL_OPENCOU
            WHERE CLASS_CODE IN (SELECT CLASS_CODE FROM TBL_CLASS WHERE CLASS_NAME = V_CLASS_NAME)
                  AND OPENCOU_CODE != V_OPENCOU_CODE;

        BEGIN

            OPEN CUR_COURSE_CHECK;
                LOOP

                FETCH CUR_COURSE_CHECK INTO V_OPENCOU_END_TEMP;

                EXIT WHEN CUR_COURSE_CHECK%NOTFOUND;

                IF(V_OPENCOU_START <= V_OPENCOU_END_TEMP )
                    THEN RAISE DATE_DEFINE_ERROR1;
                END IF;

                END LOOP;

            CLOSE CUR_COURSE_CHECK;

        END;

    END IF;

    --4.
    --CLASS_NAME에 따른 CLASS_CODE 담기
    --CLASS_CODE는 존재하지 않는다면 EMPTY값이 나오기에 EXISTS사용

    SELECT CLASS_CODE INTO V_CLASS_CODE
    FROM TBL_CLASS
    WHERE CLASS_NAME = V_CLASS_NAME;


    --테이블 업데이트
    UPDATE TBL_OPENCOU
    SET   COURSE_CODE = V_COURSE_CODE
         , CLASS_CODE = V_CLASS_CODE
         , OPENCOU_START = V_OPENCOU_START
         , OPENCOU_END = V_OPENCOU_END
    WHERE OPENCOU_CODE = V_OPENCOU_CODE;







    --예외처리
    EXCEPTION
        WHEN COURSE_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20402, '해당과정이 존재하지 않습니다. 먼저 등록하세요');
            ROLLBACK;
        WHEN CLASS_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20700, '해당강의장이 존재하지 않습니다. 먼저 등록하세요');
            ROLLBACK;
        WHEN DATE_DEFINE_ERROR1 -- -20400
            THEN RAISE_APPLICATION_ERROR(-20400, '해당 강의실은 사용중입니다.');
            ROLLBACK;

END;








--○ 개설과목
-- PRC_OPENSUB_DELETE		(개설과목 삭제)
create or replace PROCEDURE PRC_OPENSUB_DELETE
( V_OPENSUB_CODE IN TBL_OPENSUB.OPENSUB_CODE%TYPE
)
IS
    CHECK_OPENSUB_CODE NUMBER;

    V_SCO_ATTEND NUMBER;
    V_SCO_WRITE NUMBER;
    V_SCO_PRAC NUMBER;

    USER_DEFINE_ERROR1 EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;
BEGIN   

    SELECT COUNT(*) INTO CHECK_OPENSUB_CODE
    FROM TBL_OPENSUB
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;

    IF (CHECK_OPENSUB_CODE = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    -- 성적이 들어가 있다면 삭제가 안되게 한다.
    SELECT  SCO_ATTEND, SCO_WRITE, SCO_PRAC INTO V_SCO_ATTEND, V_SCO_WRITE, V_SCO_PRAC
    FROM TBL_SCO
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;

    IF (V_SCO_ATTEND >= 0)
        THEN RAISE USER_DEFINE_ERROR2;
    ELSIF (V_SCO_WRITE >= 0)
        THEN RAISE USER_DEFINE_ERROR2;
    ELSIF (V_SCO_PRAC >= 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;

    -- 삭제
    DELETE
    FROM TBL_OPENSUB
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20512, '개설 과정이 없습니다.');
                ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20518, '성적이 입력되어 있어 삭제불가합니다.');
                ROLLBACK;

    COMMIT;
END;






-- PRC_OPENSUB_INSERT		(개설과목 등록)
create or replace PROCEDURE PRC_OPENSUB_INSERT
( V_OPENCOU_CODE        IN TBL_OPENCOU.OPENCOU_CODE%TYPE
, V_SUB_CODE            IN TBL_SUB.SUB_CODE%TYPE
, V_PROF_CODE           IN TBL_PROF.PROF_CODE%TYPE
, V_BOOK_CODE           IN TBL_BOOK.BOOK_CODE%TYPE
, V_OPENSUB_START       IN TBL_OPENSUB.OPENSUB_START%TYPE
, V_OPENSUB_END         IN TBL_OPENSUB.OPENSUB_END%TYPE
, V_OPENSUB_ATTEND      IN TBL_OPENSUB.OPENSUB_ATTEND%TYPE
, V_OPENSUB_WRITE       IN TBL_OPENSUB.OPENSUB_WRITE%TYPE
, V_OPENSUB_PRAC        IN TBL_OPENSUB.OPENSUB_PRAC%TYPE
)
IS
    OPENCOU_CHECK_CODE      TBL_OPENCOU.OPENCOU_CODE%TYPE;
    SUB_CHECK_CODE      TBL_SUB.SUB_CODE%TYPE;
    PROF_CHECK_CODE         TBL_PROF.PROF_CODE%TYPE;
    BOOK_CHECK_CODE         TBL_BOOK.BOOK_CODE%TYPE;

    V_OPENSUB_CODE TBL_OPENSUB.OPENSUB_CODE%TYPE;

    COU_START DATE; --개설 과정 시작일
    COU_END DATE; --개설 과정 종료일

    OLD_START DATE; --기존 과목 시작일
    OLD_END DATE; --기존 과목 종료일

    CURSOR CUR_CHECK_DATE
    IS
    SELECT OPENSUB_START, OPENSUB_END
    FROM TBL_OPENSUB
    WHERE OPENCOU_CODE = V_OPENCOU_CODE
      AND SUB_CODE = V_SUB_CODE;


    -- 예외 선언
    USER_DEFINE_ERROR1 EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;
    USER_DEFINE_ERROR3 EXCEPTION;
    USER_DEFINE_ERROR4 EXCEPTION;
    USER_DEFINE_ERROR5 EXCEPTION;
    USER_DEFINE_ERROR6 EXCEPTION;
    USER_DEFINE_ERROR7 EXCEPTION;
BEGIN
    -- 배점의 총점이 100이 되어야 한다. 안되면 에러 발생
    IF (V_OPENSUB_ATTEND + V_OPENSUB_WRITE + V_OPENSUB_PRAC != 100)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    -- 개설 과정 체크
    SELECT NVL(MAX(OPENCOU_CODE), '0') INTO OPENCOU_CHECK_CODE
    FROM TBL_OPENCOU
    WHERE OPENCOU_CODE = V_OPENCOU_CODE;

    IF (OPENCOU_CHECK_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;

    -- 과목 여부 체크
    SELECT NVL(MAX(SUB_CODE), '0') INTO SUB_CHECK_CODE
    FROM TBL_SUB
    WHERE SUB_CODE = V_SUB_CODE;

    IF (SUB_CHECK_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;

    -- 교수 여부 체크
    SELECT NVL(MAX(PROF_CODE), '0') INTO PROF_CHECK_CODE
    FROM TBL_PROF
    WHERE PROF_CODE = V_PROF_CODE;

    IF (PROF_CHECK_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR4;
    END IF;


    -- 교재 여부 체크
    SELECT NVL(MAX(BOOK_CODE), '0') INTO BOOK_CHECK_CODE
    FROM TBL_BOOK
    WHERE BOOK_CODE = V_BOOK_CODE;

    IF (BOOK_CHECK_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR5;
    END IF;



    -- 과정 시작일과 종료일 가져오기
    SELECT OPENCOU_START, OPENCOU_END INTO COU_START, COU_END
    FROM TBL_OPENCOU
    WHERE OPENCOU_CODE = V_OPENCOU_CODE;

    -- 과목시작일자가 현재보다 과거이면 안됨
    IF (V_OPENSUB_START < SYSDATE
        -- 과목 시작일과 과목 종료일은 과정 시작일과 과정 종료일 사이에 있어야 함
        OR V_OPENSUB_START NOT BETWEEN COU_START AND COU_END
        OR V_OPENSUB_END NOT BETWEEN COU_START AND COU_END)
        THEN RAISE USER_DEFINE_ERROR6;
    END IF;



    -- 기존에 있는 과목들과 시작일, 종료일 범위가 겹치면 안된다.
    -- 커서 오픈
    OPEN CUR_CHECK_DATE;
        LOOP
            -- FETCH 한행한행받아서처리
            FETCH CUR_CHECK_DATE INTO OLD_START, OLD_END;

            EXIT WHEN CUR_CHECK_DATE%NOTFOUND; --커서값 없으면 EXIT

            -- 입력한 과목 시작일이 기존의 과목시작일 당일, 이전이고
            -- 입력한 과목 종료일이 기존의 과목시작일 당일, 이후이면 에러 발생
            IF (V_OPENSUB_START <= OLD_START AND V_OPENSUB_END >= OLD_START)
                THEN RAISE USER_DEFINE_ERROR7;            
            -- 입력한 과목 시작일이 기존의 과목시작일 당일, 이전이고
            -- 입력한 과목 종료일이 기존의 과목종료일 당일, 이후이면 에러 발생
            ELSIF (V_OPENSUB_START <= OLD_END AND V_OPENSUB_END >= OLD_END)
                THEN RAISE USER_DEFINE_ERROR7;            
            -- 입력한 과목 시작일이 기존의과목시작일 당일, 이후이고
            -- 입력한 과목 종료일이 기존의 과목종료일 당일, 이후이면 에러 발생
            ELSIF (V_OPENSUB_START >= OLD_START AND V_OPENSUB_END >= OLD_END)
                THEN RAISE USER_DEFINE_ERROR7;
            END IF;
        END LOOP;

    CLOSE CUR_CHECK_DATE;


    -- 개설과목코드 입력
    V_OPENSUB_CODE := 'OSJ' || LPAD(TO_CHAR(TBL_OPENSUB_SEQ.NEXTVAL), 3, '0');

    -- INSERT 쿼리문
    INSERT INTO TBL_OPENSUB(OPENSUB_CODE, OPENCOU_CODE, PROF_CODE, SUB_CODE, BOOK_CODE
    , OPENSUB_START, OPENSUB_END, OPENSUB_ATTEND, OPENSUB_WRITE, OPENSUB_PRAC)
    VALUES(V_OPENSUB_CODE, V_OPENCOU_CODE, V_PROF_CODE, V_SUB_CODE, V_BOOK_CODE
    , V_OPENSUB_START, V_OPENSUB_END, V_OPENSUB_ATTEND, V_OPENSUB_WRITE, V_OPENSUB_PRAC);

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20511, '배점 총합은 100점이어야 합니다.');            
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20512, '개설 과정이 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20513, '해당 과목은 없습니다.');
            ROLLBACK;            
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20514, '해당 교수는 없습니다.');
            ROLLBACK;            
        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20515, '해당 교재는 없습니다.');
            ROLLBACK;            
        WHEN USER_DEFINE_ERROR6
            THEN RAISE_APPLICATION_ERROR(-20516, '과목을 개설하려면 개설과정보다 이전/이후에는 개설할 수 없습니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR7
            THEN RAISE_APPLICATION_ERROR(-20517, '입력기간 중에 진행중인 과목이 있습니다.');
            ROLLBACK;

    -- 커밋 
    COMMIT;
END;






-- PRC_OPENSUB_UPDATE		(개설과정 수정)
create or replace PROCEDURE PRC_OPENSUB_UPDATE
( V_OPENSUB_CODE        IN TBL_OPENSUB.OPENSUB_CODE%TYPE
, V_OPENSUB_START       IN TBL_OPENSUB.OPENSUB_START%TYPE
, V_OPENSUB_END         IN TBL_OPENSUB.OPENSUB_END%TYPE
, V_OPENCOU_CODE       IN TBL_OPENCOU.OPENCOU_CODE%TYPE
, V_BOOK_CODE           IN TBL_BOOK.BOOK_CODE%TYPE
, V_SUB_CODE            IN TBL_SUB.SUB_CODE%TYPE
, V_OPENSUB_ATTEND      IN TBL_OPENSUB.OPENSUB_ATTEND%TYPE
, V_OPENSUB_WRITE       IN TBL_OPENSUB.OPENSUB_WRITE%TYPE
, V_OPENSUB_PRAC        IN TBL_OPENSUB.OPENSUB_PRAC%TYPE
)
IS
    CHECK_OPENCOU_CODE TBL_OPENCOU.OPENCOU_CODE%TYPE;
    CHECK_OPENSUB_CODE TBL_OPENSUB.OPENSUB_CODE%TYPE;
    OPENSUB_CODE_CHECK TBL_OPENSUB.OPENSUB_CODE%TYPE;

    USER_DEFINE_ERROR0 EXCEPTION;

    USER_DEFINE_ERROR1 EXCEPTION; -- 과정에 없는 것 에러 발생
    USER_DEFINE_ERROR2 EXCEPTION; -- 과목이 없는 것 에러 발생
    USER_DEFINE_ERROR3 EXCEPTION; -- 기존 과목과 기간 겹칠때 에러
    USER_DEFINE_ERROR4 EXCEPTION; -- 배점 비율 에러 발생
    USER_DEFINE_ERROR5 EXCEPTION; -- 과목 시작일, 종료일 이전 이후일때 에러 발생

    V_OPENCOU_START TBL_OPENCOU.OPENCOU_START%TYPE;
    V_OPENCOU_END TBL_OPENCOU.OPENCOU_END%TYPE;

    OPENSUB_OLD_START DATE;
    OPENSUB_OLD_END DATE;

    CURSOR CUR_CHECK_DATE
    IS
    SELECT OPENSUB_START, OPENSUB_END
    FROM TBL_OPENSUB
    WHERE OPENCOU_CODE = V_OPENCOU_CODE
      AND SUB_CODE != V_SUB_CODE;
BEGIN

    -- 개설과목코드 체크
    SELECT NVL(MAX(OPENSUB_CODE), '0') INTO OPENSUB_CODE_CHECK
    FROM TBL_OPENSUB
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;

    IF (OPENSUB_CODE_CHECK = '0')
        THEN RAISE USER_DEFINE_ERROR0;
    END IF;

    -- 개설 과정 체크
    SELECT NVL(MAX(OPENCOU_CODE), '0') INTO CHECK_OPENCOU_CODE
    FROM TBL_OPENSUB
    WHERE OPENCOU_CODE = V_OPENCOU_CODE;

    IF (CHECK_OPENCOU_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    -- 과목 시작일, 과목 종료일 이전 이후 체크
    SELECT OPENCOU_START, OPENCOU_END INTO V_OPENCOU_START, V_OPENCOU_END
    FROM TBL_OPENCOU
    WHERE OPENCOU_CODE = V_OPENCOU_CODE;

    -- 새로 입력한 과목 시작일이 가져온 과정 시작일보다 이전이거나
    -- 새로 입력한 과목 종료일이 가져온 과정 종료일보다 이후이거나
    IF (V_OPENSUB_START < V_OPENCOU_START OR V_OPENSUB_END > V_OPENCOU_END)
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;

    -- 총점 100점 초과시 에러발생
    IF (V_OPENSUB_ATTEND + V_OPENSUB_WRITE + V_OPENSUB_PRAC != 100)
        THEN RAISE USER_DEFINE_ERROR4;
    END IF;


    -- 기존에 있던 과목들과 기간이 겹칠 경우 에러 발생
    OPEN CUR_CHECK_DATE;

    LOOP
        FETCH CUR_CHECK_DATE INTO OPENSUB_OLD_START, OPENSUB_OLD_END;
        EXIT WHEN CUR_CHECK_DATE%NOTFOUND;

        -- 입력한 과목시작일이 당일, 이전이고 입력한 과목종료일이 당일, 이후이면 에러발생
        IF (V_OPENSUB_START <= OPENSUB_OLD_START AND V_OPENSUB_END >= OPENSUB_OLD_END)
            THEN RAISE USER_DEFINE_ERROR5;
        ELSIF (V_OPENSUB_START <= OPENSUB_OLD_END AND V_OPENSUB_END >= OPENSUB_OLD_END)
            THEN RAISE USER_DEFINE_ERROR5;    
        ELSIF (V_OPENSUB_START >= OPENSUB_OLD_START AND V_OPENSUB_END <= OPENSUB_OLD_END)
            THEN RAISE USER_DEFINE_ERROR5;  
        END IF;
    END LOOP;

    CLOSE CUR_CHECK_DATE;


    UPDATE TBL_OPENSUB
    SET OPENSUB_START = V_OPENSUB_START
    , OPENSUB_END = V_OPENSUB_END
    , OPENSUB_ATTEND = V_OPENSUB_ATTEND
    , OPENSUB_WRITE = V_OPENSUB_WRITE
    , OPENSUB_PRAC = V_OPENSUB_PRAC
    , BOOK_CODE = V_BOOK_CODE
    , OPENCOU_CODE = V_OPENCOU_CODE
    , SUB_CODE = V_SUB_CODE
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;



    EXCEPTION
        WHEN USER_DEFINE_ERROR0
            THEN RAISE_APPLICATION_ERROR(-20961, '개설 과목 코드가 없습니다.');
                ROLLBACK;

        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20961, '개설 과정이 없습니다.');
                ROLLBACK;

        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20963, '개설 과목은 개설 과정 기간보다 이전/이후일 수 없습니다.');
                ROLLBACK;

        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20964, '배점의 총합은 100점 이어야 합니다.');
                ROLLBACK;

        WHEN USER_DEFINE_ERROR5
            THEN RAISE_APPLICATION_ERROR(-20965, '해당 기간은 진행 중인 과목이 있습니다.');
                ROLLBACK;

    --커밋
    COMMIT;

END;







--○ 중도탈락
-- PRC_OUT_INSERT		(중도탈락 등록)
create or replace PROCEDURE PRC_OUT_INSERT
( V_SUGANG_CODE         IN TBL_OUT.SUGANG_CODE%TYPE
, V_OUT_REASON_CODE     IN TBL_OUT.OUT_REASON_CODE%TYPE
)
IS
    -- 체크용 코드 선언
    CHECK_OUT_CODE TBL_OUT.OUT_CODE%TYPE;
    CHECK_SUGANG_CODE TBL_SUGANG.SUGANG_CODE%TYPE;
    CHECK_OUT_REASON_CODE TBL_OUT_REASON.OUT_REASON_CODE%TYPE;

    CHECK_SUGANG_CODE2 NUMBER;
    -- 중도탈락 코드
    V_OUT_CODE TBL_OUT.OUT_CODE%TYPE;

    -- 과정 시작일과 종료일
    V_OPENCOU_START TBL_OPENCOU.OPENCOU_START%TYPE;
    V_OPENCOU_END TBL_OPENCOU.OPENCOU_END%TYPE;

    -- 예외 처리
    USER_DEFINE_ERROR1 EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;
    USER_DEFINE_ERROR3 EXCEPTION;
    USER_DEFINE_ERROR4 EXCEPTION;
BEGIN

    -- 수강코드가 있으면 진행, 없으면 에러 발생
    SELECT NVL((SELECT SUGANG_CODE FROM TBL_SUGANG WHERE SUGANG_CODE = V_SUGANG_CODE), '0') INTO CHECK_SUGANG_CODE
    FROM DUAL;

    IF (CHECK_SUGANG_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;


    -- OUT테이블에 수강코드가 이미 있는 것이면 에러 발생
    SELECT COUNT(*) INTO CHECK_SUGANG_CODE2
    FROM TBL_OUT
    WHERE SUGANG_CODE = V_SUGANG_CODE;

    IF (CHECK_SUGANG_CODE2 >= 1)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;


    -- 탈락사유코드가 있으면 진행, 없으면 에러 발생
    SELECT NVL((SELECT OUT_REASON_CODE FROM TBL_OUT_REASON WHERE OUT_REASON_CODE = V_OUT_REASON_CODE), '0') INTO CHECK_OUT_REASON_CODE
    FROM DUAL;

    IF (CHECK_OUT_REASON_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR3;
    END IF;   


    -- 과정시작일과 종료일 사이에 있지 않으면 중도 포기,탈락시킬 수 없게 처리한다.
    -- 수강신청 테이블에 있는 수강 코드와 입력한 수강코드가 같은 것을 찾아
    -- 과정코드를 가져오고
    -- 그 과정코드가 개설과정테이블에 있는 과정코드와 같은 것의
    -- 개설과정 시작일, 개설과정 종료일을 가져온다.
    SELECT OPENCOU_START, OPENCOU_END INTO V_OPENCOU_START, V_OPENCOU_END
    FROM TBL_OPENCOU
    WHERE OPENCOU_CODE = (SELECT OPENCOU_CODE FROM TBL_SUGANG WHERE SUGANG_CODE = V_SUGANG_CODE);

    IF (SYSDATE NOT BETWEEN V_OPENCOU_START AND V_OPENCOU_END)
        THEN RAISE USER_DEFINE_ERROR4;
    END IF;


    -- INSERT 구문
    INSERT INTO TBL_OUT(OUT_CODE, SUGANG_CODE, OUT_REASON_CODE, OUT_DATE)
    VALUES(('OUT' || LPAD(TO_CHAR(TBL_OUT_SEQ.NEXTVAL), 3, '0')), V_SUGANG_CODE, V_OUT_REASON_CODE, SYSDATE);

    -- 성적 미달을 따로 계산해서 중도탈락에 등록시키려면 성적의 총점이 몇점이하인지가 나와있지않았을까..?

    -- 예외처리 
    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20971, '이미 해당 수강을 중도 포기,탈락된 학생입니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20972, '존재하지 않은 수강코드입니다.');
            ROLLBACK;  
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20973, '존재하지 않은 탈락사유코드입니다.');
            ROLLBACK;  
        WHEN USER_DEFINE_ERROR4
            THEN RAISE_APPLICATION_ERROR(-20974, '처리할 수 있는 과정기간이 아닙니다.');
            ROLLBACK;  

    -- 커밋
    COMMIT;
END;






-- PRC_OUT_UPDATE		(중도탈락 수정)
create or replace PROCEDURE PRC_OUT_UPDATE
( V_OUT_CODE        IN TBL_OUT.OUT_CODE%TYPE
, V_OUT_REASON_CODE IN TBL_OUT_REASON.OUT_REASON_CODE%TYPE
)
IS
    CHECK_OUT_REASON_CODE TBL_OUT_REASON.OUT_REASON_CODE%TYPE;

    USER_DEFINE_ERROR1 EXCEPTION;
BEGIN

    -- 새로 적은 중도탈락사유코드가 중도탈락테이블에 존재하는 코드인지 확인
    SELECT NVL((SELECT OUT_REASON_CODE 
                FROM TBL_OUT_REASON 
                WHERE OUT_REASON_CODE = V_OUT_REASON_CODE), '0') INTO CHECK_OUT_REASON_CODE
    FROM DUAL;

    IF (CHECK_OUT_REASON_CODE != '0')
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    UPDATE TBL_OUT
    SET OUT_REASON_CODE = V_OUT_REASON_CODE
    WHERE OUT_CODE = V_OUT_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20973, '존재하지 않은 탈락사유코드입니다.');
            ROLLBACK;

    COMMIT;

END;









--○ 중도탈락 사유
-- PRC_OUT_REASON_DELETE	(중도탈락 사유 삭제)
create or replace PROCEDURE PRC_OUT_REASON_DELETE
( V_OUT_REASON_CODE IN TBL_OUT_REASON.OUT_REASON_CODE%TYPE
)
IS

    CHECK_OUT_REASON_CODE TBL_OUT_REASON.OUT_REASON_CODE%TYPE;
    CHECK_OUT_REASON_CODE_COUNT TBL_OUT.OUT_CODE%TYPE;

    USER_DEFINE_ERROR1 EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;

BEGIN

    -- 중도탈락사유 테이블에 사유코드가 있는지 체크 여부
    SELECT NVL((SELECT OUT_REASON_CODE 
                FROM TBL_OUT_REASON
                WHERE OUT_REASON_CODE = V_OUT_REASON_CODE),'0') INTO CHECK_OUT_REASON_CODE
    FROM DUAL;

    IF (CHECK_OUT_REASON_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    -- 중도탈락 테이블에 사유코드가 쓰여있는지를 체크하는 여부
    SELECT COUNT(*) INTO CHECK_OUT_REASON_CODE_COUNT
    FROM TBL_OUT
    WHERE OUT_REASON_CODE = V_OUT_REASON_CODE;

    IF (CHECK_OUT_REASON_CODE_COUNT != 0)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;

    -- DELETE 쿼리문
    DELETE 
    FROM TBL_OUT_REASON
    WHERE OUT_REASON_CODE = V_OUT_REASON_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20961, '존재하지 않는 사유코드입니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20962, '중도탈락테이블에 입력된 사유코드입니다.');
            ROLLBACK;
    --커밋
    COMMIT;
END;






-- PRC_OUT_REASON_INSERT	(중도탈락 사유 등록)
create or replace PROCEDURE PRC_OUT_REASON_INSERT
( V_OUT_REASON IN TBL_OUT_REASON.OUT_REASON%TYPE
)
IS
BEGIN
    -- INSERT 쿼리문
    INSERT INTO TBL_OUT_REASON(OUT_REASON_CODE, OUT_REASON)
    VALUES(('OR' || LPAD(TO_CHAR(TBL_OUT_REASON_SEQ.NEXTVAL), 3, '0')), V_OUT_REASON);

    -- 커밋
    COMMIT;
END;






-- PRC_OUT_REASON_UPDATE	(중도탈락 사유 수정)
create or replace PROCEDURE PRC_OUT_REASON_UPDATE
( V_OUT_REASON_CODE IN TBL_OUT_REASON.OUT_REASON_CODE%TYPE
, V_OUT_REASON IN TBL_OUT_REASON.OUT_REASON%TYPE
)
IS
    CHECK_OUT_REASON_CODE TBL_OUT_REASON.OUT_REASON_CODE%TYPE;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN

    -- 중도탈락사유코드 체크 여부
    SELECT NVL((SELECT OUT_REASON_CODE 
                FROM TBL_OUT_REASON
                WHERE OUT_REASON_CODE = V_OUT_REASON_CODE),'0') INTO CHECK_OUT_REASON_CODE
    FROM DUAL;

    IF (CHECK_OUT_REASON_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR;
    END IF;


    --UPDATE 쿼리문
    UPDATE TBL_OUT_REASON
    SET OUT_REASON = V_OUT_REASON
    WHERE OUT_REASON_CODE = V_OUT_REASON_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20961, '존재하지 않는 사유코드입니다.');
            ROLLBACK;

    --커밋
    COMMIT;
END;







--○ 교수자
-- PRC_PROF_DELETE		(교수자 삭제)
create or replace PROCEDURE PRC_PROF_DELETE
( V_PROF_CODE   IN TBL_PROF.PROF_CODE%TYPE
)
IS

BEGIN

    -- 교수 코드와 일치하는 정보 삭제
    DELETE
    FROM TBL_PROF
    WHERE PROF_CODE = V_PROF_CODE;

    --TBL_개설과목에 교수코드와 일치하는 정보 삭제
    DELETE
    FROM TBL_OPENSUB
    WHERE PROF_CODE = V_PROF_CODE;

    COMMIT;

END;






-- PRC_PROF_INSERT		(교수자 등록)
create or replace PROCEDURE PRC_PROF_INSERT
( V_PROF_NAME IN TBL_PROF.PROF_NAME%TYPE
, V_PROF_RRN  IN TBL_PROF.PROF_RRN%TYPE
, V_PROF_TEL  IN TBL_PROF.PROF_TEL%TYPE
)
IS
    V_PROF_CODE     TBL_PROF.PROF_CODE%TYPE;
    V_PROF_PW       TBL_PROF.PROF_PW%TYPE;

    E_PROF_RRN    TBL_PROF.PROF_RRN%TYPE := '0'; --중복체크를위한 변수

    PROF_DEFINE_ERROR1   EXCEPTION;
    PROF_DEFINE_ERROR2   EXCEPTION;
BEGIN
    -------에러상황-------
    --① 주민번호 중복
    --입력받은 주민번호와 일치하는 주민번호 담기
    BEGIN
        SELECT PROF_RRN INTO E_PROF_RRN FROM TBL_PROF  WHERE PROF_RRN=V_PROF_RRN;


        --동명이인을 고려해서 주민번호로 중복검사
        IF(E_PROF_RRN IS NOT NULL)
            THEN RAISE PROF_DEFINE_ERROR1;
        END IF;

        EXCEPTION 
        WHEN NO_DATA_FOUND 
        THEN E_PROF_RRN := NULL;
    END;


    --② 입력실수
    IF(V_PROF_RRN NOT LIKE '______-_______' )
        THEN RAISE PROF_DEFINE_ERROR2;
    END IF;

    IF(V_PROF_TEL NOT LIKE '___-____-____')
        THEN RAISE PROF_DEFINE_ERROR2;
    END IF;



    --시퀀스 사용해서 교수코드값 선언
    V_PROF_CODE := TO_CHAR(PROF_CODE_SEQ.NEXTVAL);
    V_PROF_CODE := 'PRO' || LPAD(V_PROF_CODE,3,'0');


    --받아온 주민번호 뒷자리로 비밀번호
    V_PROF_PW := SUBSTR(V_PROF_RRN,8);

    -- INSERT
    INSERT INTO TBL_PROF(PROF_CODE, PROF_PW, PROF_NAME, PROF_RRN, PROF_TEL)
    VALUES (V_PROF_CODE, V_PROF_PW, V_PROF_NAME, V_PROF_RRN, V_PROF_TEL);


    --예외처리
    EXCEPTION
    WHEN PROF_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20101,'주민번호가 중복됩니다.');
        ROLLBACK;
    WHEN PROF_DEFINE_ERROR2
        THEN RAISE_APPLICATION_ERROR(-20102,'입력된 정보가 잘못되었습니다.');
        ROLLBACK;


    COMMIT;

END;






-- PRC_PROF_UPDATE		(교수자 수정)
create or replace PROCEDURE PRC_PROF_UPDATE
( V_PROF_CODE   IN TBL_PROF.PROF_NAME%TYPE
, V_PROF_NAME   IN TBL_PROF.PROF_NAME%TYPE
, V_PROF_TEL    IN TBL_PROF.PROF_NAME%TYPE
)
IS
    
    PROF_DEFINE_ERROR2   EXCEPTION;
BEGIN
    -------에러상황-------
    -- 입력실수
    IF(V_PROF_TEL NOT LIKE '___-____-____')
        THEN RAISE PROF_DEFINE_ERROR2;
    END IF;



    --업데이트 (이름, 전화번호)
    UPDATE TBL_PROF
    SET   PROF_NAME = V_PROF_NAME
        , PROF_TEL = V_PROF_TEL
    WHERE PROF_CODE = V_PROF_CODE;

    --예외처리
    EXCEPTION
    --WHEN PROF_DEFINE_ERROR1
    --    THEN RAISE_APPLICATION_ERROR(-20101,'주민번호가 중복됩니다.');
    --    ROLLBACK;
    WHEN PROF_DEFINE_ERROR2
        THEN RAISE_APPLICATION_ERROR(-20102,'입력된 정보가 잘못되었습니다.');
        ROLLBACK;


    COMMIT;

END;






-- PRC_PROF_LOGIN		(교수자 로그인)
create or replace PROCEDURE PRC_PROF_LOGIN
( V_PROF_CODE   IN TBL_PROF.PROF_CODE%TYPE
, V_PROF_PW     IN TBL_PROF.PROF_PW%TYPE
)
IS
    V_PROF_NAME TBL_PROF.PROF_NAME%TYPE;
    E_PROF_PW   TBL_PROF.PROF_PW%TYPE;

    --강의과목 출력을 위한 커서
    CURSOR CUR_SUBNAME_SELECT
    IS
    SELECT TS.SUB_NAME
    FROM TBL_OPENSUB TOS JOIN TBL_SUB TS
        ON TOS.SUB_CODE=TS.SUB_CODE
    WHERE TOS.PROF_CODE =V_PROF_CODE; 

    V_SUB_NAME  TBL_SUB.SUB_NAME%TYPE;  

    PROF_DEFINE_ERROR   EXCEPTION;
BEGIN

    SELECT PROF_PW, PROF_NAME INTO E_PROF_PW, V_PROF_NAME 
    FROM TBL_PROF 
    WHERE PROF_CODE = V_PROF_CODE;


    IF(E_PROF_PW != V_PROF_PW)
        THEN RAISE PROF_DEFINE_ERROR;
    END IF;


    -- 강의중인 과목 출력
    DBMS_OUTPUT.PUT_LINE(V_PROF_NAME || '님 로그인되었습니다.');

    -- 커서오픈
    OPEN CUR_SUBNAME_SELECT;
    -- 커서 데이터 처리
    LOOP
        FETCH CUR_SUBNAME_SELECT INTO V_SUB_NAME;

        EXIT WHEN CUR_SUBNAME_SELECT%NOTFOUND;

        --출력
        DBMS_OUTPUT.PUT_LINE(' 강의과목 : '||V_SUB_NAME);
    END LOOP;
    -- 커서클로즈
    CLOSE CUR_SUBNAME_SELECT;

    --예외처리
    EXCEPTION
        WHEN NO_DATA_FOUND 
        THEN RAISE_APPLICATION_ERROR(-20050,'아이디 또는 패스워드를 잘못 입력하셨습니다.');
        WHEN PROF_DEFINE_ERROR
        THEN RAISE_APPLICATION_ERROR(-20050,'아이디 또는 패스워드를 잘못 입력하셨습니다.');
             ROLLBACK;


    COMMIT;
END;






-- PRC_PROF_OUT			(교수자 학생 중도탈락 처리)
create or replace PROCEDURE PRC_PROF_OUT
( V_SUGANG_CODE IN TBL_SUGANG.SUGANG_CODE%TYPE
)
IS
    V_FLAG NUMBER := 1;
    V_OUT_REASON_CODE  TBL_OUT_REASON.OUT_REASON_CODE%TYPE;
    V_OUT_CODE         TBL_OUT.OUT_CODE%TYPE;
    USER_DEFINE_ERROR1 EXCEPTION;
    USER_DEFINE_ERROR2 EXCEPTION;

BEGIN

    -- 해당 수강코드가 존재하는지 부터 확인
    SELECT COUNT(*) INTO V_FLAG
    FROM TBL_SUGANG
    WHERE V_SUGANG_CODE = SUGANG_CODE; 

    -- 수강코드 없으면 없는 학생으로 간주
    IF(V_FLAG = 0)
        THEN RAISE USER_DEFINE_ERROR1;
    END IF;

    -- 플래그 초기화
    V_FLAG := 1;

    -- 중도 탈락이 이미 되어있는 학생인지 부터 확인
    SELECT COUNT(*) INTO V_FLAG
    FROM TBL_OUT
    WHERE V_SUGANG_CODE = SUGANG_CODE;

    -- 수강코드가 이미 중도탈락 테이블에 존재한다면 중복 에러 
    IF(V_FLAG = 1)
        THEN RAISE USER_DEFINE_ERROR2;
    END IF;

    -- 해당 수강코드 존재 AND 중복아닐 경우
    -- 해당 수강코드를 가진 학생을 중도탈락 처리
    SELECT OUT_REASON_CODE INTO V_OUT_REASON_CODE
    FROM TBL_OUT_REASON
    WHERE OUT_REASON = '수업 태도 불량';

    -- 중도탈락 코드 생성
    V_OUT_CODE := TO_CHAR(TBL_OUT_SEQ.NEXTVAL);
    V_OUT_CODE := 'OUT' || LPAD(V_OUT_CODE,3,0);

    -- 중도탈락 테이블 INSERT
    INSERT INTO TBL_OUT
    VALUES(V_OUT_CODE, V_SUGANG_CODE, V_OUT_REASON_CODE, SYSDATE);


    EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20972,'존재하지 않는 수강코드입니다.');
            ROLLBACK;
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20971, '이미 해당 수강을 중도 포기, 탈락된 학생입니다.');
            ROLLBACK;

        COMMIT;

END;







--○ 교수자 성적관리
-- PRC_SCO_INSERT		(교수자 성적 입력)
create or replace PROCEDURE PRC_SCO_INSERT
( V_SUGANG_CODE IN TBL_SUGANG.SUGANG_CODE%TYPE
, V_OPENSUB_CODE IN TBL_OPENSUB.OPENSUB_CODE%TYPE
, V_SCO_ATTEND IN TBL_SCO.SCO_ATTEND%TYPE
, V_SCO_WRITE IN TBL_SCO.SCO_WRITE%TYPE
, V_SCO_PRAC IN TBL_SCO.SCO_PRAC%TYPE
)

IS
    --필요변수
    --1.시퀀스를 통해입력될 성적코드
    --2.3,4번을 위한 CHECK 변수 2개(수강,개설과목)
    --3.사용자가 입력한 개설 과목코드가 없으면 띄울 에러
    --4.수강코드가 없으면 띄울 에러
    --5.중도탈락자를 위한 중도탈락 코드
    --6.중도탈락자를 가려내기 위한 개설과목의 배점항목 3개
    --7.배점항목에 따른 총점 변수
    
    V_SCO_CODE                  TBL_SCO.SCO_CODE%TYPE;
    V_OUT_CODE                  TBL_OUT.OUT_CODE%TYPE;
    V_OUT_REASON_CODE1          TBL_OUT_REASON.OUT_REASON_CODE%TYPE; --성적미달
    V_OUT_REASON_CODE2          TBL_OUT_REASON.OUT_REASON_CODE%TYPE; --출결부족


    V_OPENSUB_CODE_CHECK            NUMBER(2);
    V_OPENSUB_CODE_EXIST_CHECK      NUMBER(2);
    V_SUGANG_CHECK                  NUMBER(2);
    V_OUT_CODE_CHECK                NUMBER(2);
    V_TOTAL                         NUMBER(3);


    V_OPENSUB_ATTEND        TBL_OPENSUB.OPENSUB_ATTEND%TYPE;
    V_OPENSUB_WRITE         TBL_OPENSUB.OPENSUB_WRITE%TYPE;
    V_OPENSUB_PRAC          TBL_OPENSUB.OPENSUB_PRAC%TYPE;

    V_SCO_ATTEND_RESULT        TBL_SCO.SCO_ATTEND%TYPE;
    V_SCO_WRITE_RESULT         TBL_SCO.SCO_WRITE%TYPE;
    V_SCO_PRAC_RESULT          TBL_SCO.SCO_PRAC%TYPE;

    V_OPENSUB_ATTEND_STANDARD       TBL_OPENSUB.OPENSUB_ATTEND%TYPE; --출결부족 판단

    SUGANG_DEFINE_ERROR1    EXCEPTION;
    OPENSUB_DEFINE_ERROR1    EXCEPTION;
    SCO_DEFINE_ERROR1       EXCEPTION;   --같은 수강코드에 같은 과목 입력금지
    OUT_DEFINE_ERROR1       EXCEPTION;    --   -20971




BEGIN


    --수강코드가 없을때
    SELECT COUNT(*) INTO V_SUGANG_CHECK 
    FROM TBL_SUGANG
    WHERE SUGANG_CODE = V_SUGANG_CODE;

    --입력한 개설과목코드가 수강코드를 통해 불러온 개설과정내에 없을때
    SELECT  COUNT(*) INTO V_OPENSUB_CODE_CHECK
    FROM TBL_OPENSUB
    WHERE OPENSUB_CODE IN ( SELECT OPS.OPENSUB_CODE
                            FROM TBL_OPENCOU OPC JOIN TBL_SUGANG SG
                            ON OPC.OPENCOU_CODE = SG.OPENCOU_CODE
                            JOIN TBL_OPENSUB OPS
                            ON OPC.OPENCOU_CODE = OPS.OPENCOU_CODE
                            WHERE SG.SUGANG_CODE = V_SUGANG_CODE
                                AND OPS.OPENSUB_CODE = V_OPENSUB_CODE);


    --이미 같은 수강코드에 해당 과목 점수 입력한경우

    SELECT COUNT(*) INTO V_OPENSUB_CODE_EXIST_CHECK
    FROM TBL_SCO
    WHERE OPENSUB_CODE IN (SELECT OPENSUB_CODE FROM TBL_SCO 
                            WHERE SUGANG_CODE = V_SUGANG_CODE
                                   AND OPENSUB_CODE = V_OPENSUB_CODE);


    IF(V_SUGANG_CHECK = 0)
        THEN RAISE SUGANG_DEFINE_ERROR1;

        ELSIF (V_OPENSUB_CODE_CHECK = 0)
            THEN RAISE OPENSUB_DEFINE_ERROR1;
        ELSIF (V_OPENSUB_CODE_EXIST_CHECK != 0)
            THEN RAISE SCO_DEFINE_ERROR1;
    END IF;

    V_SCO_CODE := TO_CHAR(SEQ_SCO.NEXTVAL);
    V_SCO_CODE := 'SCO' || LPAD(V_SCO_CODE,3,0);


    INSERT INTO TBL_SCO(SCO_CODE, OPENSUB_CODE, SUGANG_CODE, SCO_ATTEND, SCO_WRITE, SCO_PRAC)
    VALUES(V_SCO_CODE, V_OPENSUB_CODE, V_SUGANG_CODE, V_SCO_ATTEND, V_SCO_WRITE, V_SCO_PRAC);


   --성적 미달 OR 출결미달이라면 바로 중도탈락에 등록



   -- 해당 학생은 이미 중도탈락에 등록이 되어있다고 말해주기
   --탈락 코드에 존재하는지 확인


    SELECT COUNT(*) INTO V_OUT_CODE_CHECK
    FROM TBL_OUT
    WHERE SUGANG_CODE = V_SUGANG_CODE;

    IF(V_OUT_CODE_CHECK != 0)
       THEN RAISE OUT_DEFINE_ERROR1;   --   -20971
    END IF;


    --개설과목에서 배점가져오기
    SELECT OPENSUB_ATTEND, OPENSUB_WRITE, OPENSUB_PRAC
          INTO V_OPENSUB_ATTEND
             , V_OPENSUB_WRITE
             , V_OPENSUB_PRAC
    FROM TBL_OPENSUB
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;


    --출결점수 기준에  입력된 출결점수담기
    V_OPENSUB_ATTEND_STANDARD := V_SCO_ATTEND;

    --배점*출결,필기,실기 점수
    V_SCO_ATTEND_RESULT := (V_OPENSUB_ATTEND/100 * V_SCO_ATTEND); 
    V_SCO_WRITE_RESULT := (V_OPENSUB_WRITE/100 * V_SCO_WRITE);
    V_SCO_PRAC_RESULT := (V_OPENSUB_PRAC/100 * V_SCO_PRAC);

    --세 점수의 총합
    V_TOTAL := V_SCO_ATTEND_RESULT + V_SCO_WRITE_RESULT + V_SCO_PRAC_RESULT;


    --중도탈락코드 생성
    V_OUT_CODE := TO_CHAR(TBL_OUT_SEQ.NEXTVAL);
    V_OUT_CODE := 'OUT' || LPAD(V_OUT_CODE,3,0);

    --중도탈락사유 코드 가져오기

    SELECT OUT_REASON_CODE INTO  V_OUT_REASON_CODE1
    FROM TBL_OUT_REASON
    WHERE OUT_REASON = '성적 미달';

    SELECT OUT_REASON_CODE INTO  V_OUT_REASON_CODE2
    FROM TBL_OUT_REASON
    WHERE OUT_REASON = '출결 불량';


    IF(V_OPENSUB_ATTEND_STANDARD < 70 AND V_OPENSUB_ATTEND>0)   --학원 출결부족 기준 70
        THEN INSERT INTO TBL_OUT(OUT_CODE, SUGANG_CODE, OUT_REASON_CODE, OUT_DATE)
            VALUES(V_OUT_CODE, V_SUGANG_CODE, V_OUT_REASON_CODE2 , SYSDATE);


    ELSIF(V_TOTAL <50)
        THEN INSERT INTO TBL_OUT(OUT_CODE, SUGANG_CODE, OUT_REASON_CODE, OUT_DATE)
            VALUES(V_OUT_CODE, V_SUGANG_CODE, V_OUT_REASON_CODE1 , SYSDATE);
    END IF;

    COMMIT;

    --예외처리
    EXCEPTION
        WHEN SUGANG_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20903,'수강코드가 존재하지 않습니다 다시 입력하세요');
            ROLLBACK;
        WHEN  OPENSUB_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20966,'개설과목이 존재하지 않습니다 다시 입력하세요');
            ROLLBACK;
        WHEN SCO_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20600,'해당 과목의 성적은 이미 입력했습니다.');   ------------------아직 등록안했다. -20600번
            ROLLBACK;
        WHEN OUT_DEFINE_ERROR1   --   -20971
            THEN RAISE_APPLICATION_ERROR(-20971, '이미 해당 수강을 중도 포기,탈락된 학생입니다.');
            ROLLBACK;

END;







-- PRC_SCO_DELETE		(교수자 성적 삭제)
create or replace PROCEDURE PRC_SCO_DELETE
( V_SCO_CODE IN TBL_SCO.SCO_CODE%TYPE
, V_OPENSUB_CODE IN TBL_OPENSUB.OPENSUB_CODE%TYPE
)

IS
    --성적코드를 통해 수강신청 코드를 가져와서 중도탈락을 조회할 변수
    
    V_SUGANG_CODE TBL_SUGANG.SUGANG_CODE%TYPE;
    V_OUT_CODE TBL_OUT.OUT_CODE%TYPE;

    V_SCO_CODE_CHECK NUMBER(2);
    V_OUT_CODE_CHECK NUMBER(2);

    V_OUT_FLAG CHAR(2);           --해당 학생이 중도탈락 테이블에 존재하는지 확인하는 변수

    --사용자 정의 에러
    SCO_DEFINE_ERROR1 EXCEPTION;   --  -20601번 성적코드 없음


BEGIN

    --성적코드가 존재하는지 확인

    SELECT COUNT(*) INTO V_SCO_CODE_CHECK
    FROM TBL_SCO
    WHERE SCO_CODE = V_SCO_CODE;


    IF (V_SCO_CODE_CHECK = 0)
        THEN RAISE SCO_DEFINE_ERROR1;    
    END IF;

    --성적코드가 존재한다면 INSERT시 수강코드가 같이 입력瑛뺐痼譴퓐
    --성적코드를 통해 수강신청 코드 가져오기
    SELECT SUGANG_CODE INTO V_SUGANG_CODE
    FROM TBL_SCO
    WHERE SCO_CODE = V_SCO_CODE
          AND OPENSUB_CODE = V_OPENSUB_CODE;


    --탈락 코드에 존재하는지 확인


    SELECT COUNT(*) INTO V_OUT_CODE_CHECK
    FROM TBL_OUT
    WHERE SUGANG_CODE = V_SUGANG_CODE;

    IF(V_OUT_CODE_CHECK != 0)
       THEN
            --점수테이블에서 수강코드를 통해 중도테이블과 JOIN해 해당 수강코드의 중도 탈락코드 가져오기 
        SELECT TOUT.OUT_CODE INTO V_OUT_CODE
        FROM TBL_OUT TOUT JOIN TBL_SCO SCO
        ON TOUT.SUGANG_CODE = SCO.SUGANG_CODE
        WHERE SCO.SCO_CODE = V_SCO_CODE;
        V_OUT_FLAG := '1';     --탈락코드에 존재한다는 의미


        ELSE
            V_OUT_FLAG := '2';
    END IF;


    DELETE 
    FROM TBL_SCO
    WHERE SCO_CODE = V_SCO_CODE
          AND OPENSUB_CODE = V_OPENSUB_CODE;



    IF (V_OUT_FLAG = '1')
        THEN
            DELETE
            FROM TBL_OUT
            WHERE OUT_CODE = V_OUT_CODE;

    END IF;


    EXCEPTION
        WHEN SCO_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20601,'해당 성적코드는 존재하지 않습니다.');
            ROLLBACK;



END;






-- PRC_SCO_UPDATE		(교수자 성적 수정)
create or replace PROCEDURE PRC_SCO_UPDATE
( V_SCO_CODE   IN TBL_SCO.SCO_CODE%TYPE
, V_SCO_ATTEND IN TBL_SCO.SCO_ATTEND%TYPE
, V_SCO_WRITE IN TBL_SCO.SCO_WRITE%TYPE
, V_SCO_PRAC IN TBL_SCO.SCO_PRAC%TYPE
)

IS
    
    
    V_SUGANG_CODE               TBL_SCO.SUGANG_CODE%TYPE;
    V_OPENSUB_CODE              TBL_SCO.OPENSUB_CODE%TYPE;

    V_SCO_CODE_CHECK            NUMBER(2);
    V_OUT_CODE                  TBL_OUT.OUT_CODE%TYPE;
    V_OUT_CHECK                 NUMBER(2);
    V_TOTAL                     NUMBER(3);
    V_OUT_REASON_CODE1          TBL_OUT_REASON.OUT_REASON_CODE%TYPE; --성적미달
    V_OUT_REASON_CODE2          TBL_OUT_REASON.OUT_REASON_CODE%TYPE; --출결부족


    V_OPENSUB_ATTEND            TBL_OPENSUB.OPENSUB_ATTEND%TYPE;
    V_OPENSUB_WRITE             TBL_OPENSUB.OPENSUB_WRITE%TYPE;
    V_OPENSUB_PRAC              TBL_OPENSUB.OPENSUB_PRAC%TYPE;

    V_SCO_ATTEND_RESULT         TBL_SCO.SCO_ATTEND%TYPE;
    V_SCO_WRITE_RESULT          TBL_SCO.SCO_WRITE%TYPE;
    V_SCO_PRAC_RESULT           TBL_SCO.SCO_PRAC%TYPE;

    SCO_DEFINE_ERROR1 EXCEPTION; --없는 성적코드

    OUT_DEFINE_ERROR1 EXCEPTION;  --성적수정으로 성적,출결이 기준 이상이라 OUT테이블에서 삭제하는 구문이 돌아간 후에도
                                  --수정된 성적도 중도탈락테이블에 들어가야한다면
                                  --탈락테이블에서 해당학생을 조회하여
                                  --이미 존재한다면 새로 INSERT하지 않게하는 사용자 정의 에러

BEGIN

    SELECT COUNT(*) INTO V_SCO_CODE_CHECK
    FROM TBL_SCO
    WHERE SCO_CODE = V_SCO_CODE;



    IF(V_SCO_CODE_CHECK = 0)
        THEN RAISE SCO_DEFINE_ERROR1;
    END IF;

    UPDATE TBL_SCO
    SET   SCO_ATTEND = V_SCO_ATTEND
        , SCO_WRITE = V_SCO_WRITE
        , SCO_PRAC = V_SCO_PRAC
    WHERE SCO_CODE = V_SCO_CODE;



    --※만약 중도탈락에 등록되었고 
    -- 수정된 점수가 중도탈락에 안걸린다면 중도탈락에서 삭제

    --단 중도탈락에 없었으나 성적수정으로 인해 등록된다면
    --   중도탈락에 등록

    --성적코드로 TBL_SCO에서 수강코드와 개설과목코드 가져오기

    SELECT SUGANG_CODE, OPENSUB_CODE INTO V_SUGANG_CODE, V_OPENSUB_CODE
    FROM TBL_SCO
    WHERE SCO_CODE = V_SCO_CODE;

    --중도탈락코드 생성
    V_OUT_CODE := TO_CHAR(TBL_OUT_SEQ.NEXTVAL);
    V_OUT_CODE := 'OUT' || LPAD(V_OUT_CODE,3,0);

    --중도탈락사유 코드 가져오기

    SELECT OUT_REASON_CODE INTO  V_OUT_REASON_CODE1
    FROM TBL_OUT_REASON
    WHERE OUT_REASON = '성적 미달';

    SELECT OUT_REASON_CODE INTO  V_OUT_REASON_CODE2
    FROM TBL_OUT_REASON
    WHERE OUT_REASON = '출결 불량';



    --개설과목에서 배점가져오기
    SELECT OPENSUB_ATTEND, OPENSUB_WRITE, OPENSUB_PRAC
          INTO V_OPENSUB_ATTEND
             , V_OPENSUB_WRITE
             , V_OPENSUB_PRAC
    FROM TBL_OPENSUB
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;



    --배점*출결,필기,실기 점수
    V_SCO_ATTEND_RESULT := (V_OPENSUB_ATTEND/100 * V_SCO_ATTEND); 
    V_SCO_WRITE_RESULT := (V_OPENSUB_WRITE/100 * V_SCO_WRITE);
    V_SCO_PRAC_RESULT := (V_OPENSUB_PRAC/100 * V_SCO_PRAC);

    --세 점수의 총합
    V_TOTAL := V_SCO_ATTEND_RESULT + V_SCO_WRITE_RESULT + V_SCO_PRAC_RESULT;



    IF( (V_TOTAL >50 AND V_SCO_ATTEND >70) AND V_OPENSUB_ATTEND >0 )
        THEN 
            DELETE
            FROM TBL_OUT
            WHERE SUGANG_CODE = V_SUGANG_CODE;
            --여기 실행안됨

    END IF;

    --DELETE 구문이 실행된후에 성적이 수정된 학생이 TBL_OUT에 남아있다면 INSERT를 새로하지않고
    -- 없다면 INSERT한다.

    SELECT COUNT(*) INTO V_OUT_CHECK
    FROM TBL_OUT
    WHERE SUGANG_CODE = V_SUGANG_CODE;


    IF (V_OUT_CHECK = 1)
        THEN RAISE OUT_DEFINE_ERROR1;

    ELSIF(V_TOTAL <50 AND V_OUT_CHECK = 0)
            THEN INSERT INTO TBL_OUT(OUT_CODE, SUGANG_CODE, OUT_REASON_CODE, OUT_DATE)
            VALUES(V_OUT_CODE, V_SUGANG_CODE, V_OUT_REASON_CODE1 , SYSDATE);

    ELSIF(V_SCO_ATTEND < 70 AND V_OPENSUB_ATTEND>0 AND V_OUT_CHECK = 0)   --학원 출결부족 기준 70
        THEN 
            INSERT INTO TBL_OUT(OUT_CODE, SUGANG_CODE, OUT_REASON_CODE, OUT_DATE)
            VALUES(V_OUT_CODE, V_SUGANG_CODE, V_OUT_REASON_CODE2 , SYSDATE);

    END IF;


    EXCEPTION
        WHEN OUT_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20971,'이미 해당 수강을 중도 포기,탈락된 학생입니다.');
            ROLLBACK;
          WHEN SCO_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20601,'해당 성적코드는 존재하지 않습니다.');
            ROLLBACK;

    COMMIT;

END;






	
--○ 학생
-- PRC_STD_DELETE		(학생 삭제)
create or replace PROCEDURE PRC_STD_DELETE
( V_STD_CODE IN  TBL_STD.STD_CODE%TYPE
)
IS
    --사용자 정의 예외처리 선언
    USER_DEFINE_ERROR  EXCEPTION;
    --학생코드 유무 확인할 변수 선언
    VN_CNT          NUMBER := 0;

BEGIN

    --DELETE문 정상수행 여부 확인(입력받은 학생코드가 존재하지 않을 때)
     SELECT COUNT(*) INTO VN_CNT
     FROM TBL_STD
     WHERE STD_CODE = V_STD_CODE;

     IF VN_CNT = 0 -- 학번 존재하지 않을 시 
        THEN RAISE USER_DEFINE_ERROR; -- 에러 발생
     END IF;

    --DELETE문 쿼리 
    DELETE
    FROM TBL_STD
    WHERE STD_CODE = V_STD_CODE;

    --사용자 정의 예외처리
    EXCEPTION
    WHEN USER_DEFINE_ERROR
        THEN RAISE_APPLICATION_ERROR(-20032, '해당 학번이 존재하지 않습니다.');
    ROLLBACK;
    WHEN OTHERS
        THEN ROLLBACK;
    COMMIT;   
END;






-- PRC_STD_INSERT		(학생 등록)
create or replace PROCEDURE PRC_STD_INSERT
( V_STD_NAME IN  TBL_STD.STD_NAME%TYPE
, V_STD_RRN  IN  TBL_STD.STD_RRN%TYPE
)
IS
    -- 추가 변수 선언
    V_STD_CODE    TBL_STD.STD_CODE%TYPE;
    V_STD_PW      TBL_STD.STD_PW%TYPE;

    --사용자 정의 예외 선언1 (이미 존재하는 주민번호일 시)
    USER_DEFINE_ERROR1  EXCEPTION;
    -- 동일 주민번호 존재 여부 판단할 변수 선언
    VN_CNT NUMBER;

    -- 사용자 정의 예외선언2(주민번호 자릿수 OR 형식 오입력 시)
    USER_DEFINE_ERROR2 EXCEPTION;


BEGIN

    ----INSERT문 실행 여부 확인
    SELECT COUNT(*) INTO VN_CNT
    FROM TBL_STD
    WHERE STD_RRN = V_STD_RRN;


    IF (VN_CNT != 0)    -- 동일한 주민번호 입력 시 
        THEN RAISE USER_DEFINE_ERROR1;  -- 에러 발생
    END IF;

    --INSERT문 실행 여부 확인 
    IF (V_STD_RRN NOT LIKE '______-_______')    --주민번호 자릿수 OR 형식 오입력 시
        THEN RAISE USER_DEFINE_ERROR2;          --에러발생
    END IF;


    --받아온 주민번호 뒤 7자리로 비밀번호 설정
    V_STD_PW := SUBSTR(V_STD_RRN,8,7);

     --학번 시퀀스
     V_STD_CODE := TO_CHAR(STD_SEQ.NEXTVAL);
     V_STD_CODE := 'STD' || LPAD(V_STD_CODE,3,'0');


    --INSERT문    
    INSERT INTO TBL_STD(STD_CODE, STD_NAME, STD_PW, STD_RRN)
    VALUES (V_STD_CODE, V_STD_NAME, V_STD_PW, V_STD_RRN);


    --사용자 정의 예외처리
    EXCEPTION
    WHEN USER_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20030, '이미 등록된 학생입니다');
    ROLLBACK;
    WHEN USER_DEFINE_ERROR2
        THEN RAISE_APPLICATION_ERROR(-20031, '주민번호 자릿수 혹은 입력 형식이 잘못되었습니다. '-' 포함하여 입력해주세요!');
    WHEN OTHERS
        THEN ROLLBACK;
    COMMIT;  
END;






-- PRC_STD_LOGIN		(학생 로그인)
create or replace PROCEDURE PRC_STD_LOGIN --(학생 아이디, 학생 패스워드)
( V_STD_CODE   IN   TBL_STD.STD_CODE%TYPE
, V_STD_PW     IN   TBL_STD.STD_PW%TYPE
)
IS
     -- 로그인 유효성 확인위한 변수
     V_FLAG1  NUMBER; 
     V_FLAG2  NUMBER;
     V_FLAG3  NUMBER;
     V_FLAG4  NUMBER;
     --사용자 정의 예외                    
     USER_DEFINE_ERROR1 EXCEPTION;
     USER_DEFINE_ERROR2 EXCEPTION;
     USER_DEFINE_ERROR3 EXCEPTION;

     V_STD_NAME  TBL_STD.STD_NAME%TYPE;

     -- 수강 완료 과목 출력을 위한 커서 선언
     CURSOR CUR_SUB_SELECT
     IS
     SELECT SUB.SUB_NAME
     FROM TBL_STD STD 
     JOIN TBL_SUGANG SG
     ON STD.STD_CODE = SG.STD_CODE
        JOIN TBL_OPENCOU OC
        ON SG.OPENCOU_CODE = OC.OPENCOU_CODE
            JOIN TBL_OPENSUB OS
            ON OC.OPENCOU_CODE = OS.OPENCOU_CODE
                JOIN TBL_SUB SUB
                ON OS.SUB_CODE = SUB.SUB_CODE
     WHERE STD.STD_CODE = V_STD_CODE AND OS.OPENSUB_END < SYSDATE;  --로그인한 해당 학생 + 수강완료된 과목만 출력

     -- 커서 출력을 위한 변수 선언
     V_STD_SUB  TBL_SUB.SUB_NAME%TYPE;


BEGIN
     -- 로그인 유효성 확인
     SELECT COUNT(*) INTO V_FLAG1
     FROM TBL_STD
     WHERE STD_PW = V_STD_PW;

     SELECT COUNT(*) INTO V_FLAG2
     FROM TBL_STD
     WHERE STD_CODE = V_STD_CODE;

     SELECT STD_PW INTO V_FLAG3
     FROM TBL_STD
     WHERE STD_CODE = V_STD_CODE;

     IF (V_FLAG1 = 0)      -- 비밀번호만 존재하지 않을경우
        THEN RAISE USER_DEFINE_ERROR1;   --에러발생
     ELSIF (V_FLAG2 = 0)   --아이디만 존재하지 않을 경우
        THEN RAISE USER_DEFINE_ERROR2;   --에러발생
     ELSIF (V_FLAG3 != V_STD_PW)  --아이디와 비밀번호 모두 존재하지만 둘이 일치하지 않을 경우, 
        THEN RAISE USER_DEFINE_ERROR3;   --에러발생
     END IF;

     -- 중도 탈락 학생 확인할 쿼리
     SELECT COUNT(*) INTO V_FLAG4
     FROM VIEW_OUT_IDPW
     WHERE V_STD_CODE = 학번;

     -- ~님 로그인 되었습니다
     SELECT STD_NAME INTO V_STD_NAME
     FROM TBL_STD
     WHERE STD_CODE = V_STD_CODE;


     IF (V_FLAG4 = 1) --중도탈락IDPW 뷰에 입력받은 학번이 있다면,
        THEN DBMS_OUTPUT.PUT_LINE(V_STD_NAME || '님 로그인 되었습니다. 수강하시는 과정 중도탈락되어 수강완료한 과목만 성적 확인이 가능합니다.');
     ELSE   -- 그것이 아니라면,
         DBMS_OUTPUT.PUT_LINE(V_STD_NAME || '님 로그인 되었습니다.');
     END IF;

     -- 수강 완료 과목 출력
     -- 커서오픈
     OPEN CUR_SUB_SELECT;
     -- 커서 데이터 처리
     LOOP
        FETCH CUR_SUB_SELECT INTO V_STD_SUB;

        EXIT WHEN CUR_SUB_SELECT%NOTFOUND;

        --출력
        DBMS_OUTPUT.PUT_LINE(' 수강 완료 과목 : ' || V_STD_SUB );
     END LOOP;
     -- 커서클로즈
     CLOSE CUR_SUB_SELECT;

     -- 예외 처리  
     EXCEPTION
        WHEN USER_DEFINE_ERROR1
            THEN RAISE_APPLICATION_ERROR(-20303,'아이디 또는 패스워드가 일치하지 않습니다.'); 
        WHEN USER_DEFINE_ERROR2
            THEN RAISE_APPLICATION_ERROR(-20303,'아이디 또는 패스워드가 일치하지 않습니다.');
        WHEN USER_DEFINE_ERROR3
            THEN RAISE_APPLICATION_ERROR(-20303,'아이디 또는 패스워드가 일치하지 않습니다.');
        ROLLBACK; 
     COMMIT;
END;






-- PRC_STD_UPDATE		(학생 수정)
create or replace PROCEDURE PRC_STD_UPDATE
( V_STD_CODE IN TBL_STD.STD_CODE%TYPE
, V_STD_NAME IN TBL_STD.STD_NAME%TYPE
)
IS

    --사용자 정의 예외 선언
    USER_DEFINE_ERROR1  EXCEPTION;

    --학생코드 존재유무 확인 변수 선언
    VN_CNT NUMBER :=0;


BEGIN

     --UPDATE문 실행 여부 확인
     SELECT COUNT(*) INTO VN_CNT
     FROM TBL_STD
     WHERE STD_CODE = V_STD_CODE;

     IF VN_CNT = 0
     THEN RAISE USER_DEFINE_ERROR1;
     END IF;


     --TBL_STD UPDATE문 실행
     UPDATE TBL_STD
     SET STD_NAME = V_STD_NAME
     WHERE STD_CODE = V_STD_CODE;


     --사용자 정의 예외 처리
     EXCEPTION
     WHEN USER_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20032, '해당 학번이 존재하지 않습니다');
     ROLLBACK;
     WHEN OTHERS
        THEN ROLLBACK;

    COMMIT;       
END;






--○ 과목
-- PRC_SUB_DELETE		(과목 삭제)
create or replace PROCEDURE PRC_SUB_DELETE
( V_SUB_CODE IN TBL_SUB.SUB_CODE%TYPE
)
IS 
    SUB_CHECK_CODE TBL_SUB.SUB_CODE%tYPE;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN

    SELECT NVL((SELECT SUB_CODE
                FROM TBL_SUB
                WHERE SUB_CODE = V_SUB_CODE), '0') INTO SUB_CHECK_CODE
    FROM DUAL;

    IF (SUB_CHECK_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR;
    END IF;

    DELETE
    FROM TBL_SUB
    WHERE SUB_CODE = V_SUB_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20503, '존재하지 않는 과목입니다.');
                ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;

    --커밋
    COMMIT;   
END;






-- PRC_SUB_INSERT		(과목 등록)
create or replace PROCEDURE PRC_SUB_INSERT
( V_SUB_NAME     IN TBL_SUB.SUB_NAME%TYPE
)
IS 
    SUB_CHECK_NAME TBL_SUB.SUB_NAME%TYPE;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN
    -- 이미 있는 과목명인지 확인
    SELECT NVL((SELECT SUB_NAME
                FROM TBL_SUB
                WHERE SUB_NAME = V_SUB_NAME), '0') INTO SUB_CHECK_NAME
    FROM DUAL;

    -- 조건 : 에러 발생
    IF (SUB_CHECK_NAME != '0')
        THEN RAISE USER_DEFINE_ERROR;
    END IF;

    INSERT INTO TBL_SUB(SUB_CODE, SUB_NAME)
    VALUES(('SUB' || LPAD(TO_CHAR(TBL_SUB_SEQ.NEXTVAL), 3, '0')), V_SUB_NAME);

    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20501, '이미 등록된 과목입니다.');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK;

    -- 커밋
    COMMIT;
END;






-- PRC_SUB_UPDATE		(과목 수정)
create or replace PROCEDURE PRC_SUB_UPDATE
( V_SUB_CODE    IN TBL_SUB.SUB_CODE%TYPE -- 과목코드
, V_SUB_NAME    IN TBL_SUB.SUB_NAME%TYPE -- 수정할 과목명
)
IS 
    SUB_CHECK_CODE TBL_SUB.SUB_CODE%TYPE;
    USER_DEFINE_ERROR EXCEPTION;
BEGIN

    -- 과목코드가 같은지 판단하기 위한 조회
    SELECT NVL((SELECT SUB_CODE
                FROM TBL_SUB
                WHERE SUB_CODE = V_SUB_CODE), '0') INTO SUB_CHECK_CODE
    FROM DUAL;

    -- 조건 판단으로 에러발생, 코드가 없으면 예외
    IF (SUB_CHECK_CODE = '0')
        THEN RAISE USER_DEFINE_ERROR;
    END IF;


    -- 과목이름 변경 
    UPDATE TBL_SUB
    SET SUB_NAME = V_SUB_NAME
    WHERE SUB_CODE = V_SUB_CODE;

    EXCEPTION
        WHEN USER_DEFINE_ERROR
            THEN RAISE_APPLICATION_ERROR(-20502, '존재하지 않은 코드입니다..');
            ROLLBACK;
        WHEN OTHERS
            THEN ROLLBACK; 
    -- 커밋
    COMMIT;
END;







--○ 수강신청
-- PRC_SUGANG_DELETE		(수강신청 삭제)
create or replace PROCEDURE PRC_SUGANG_DELETE
( V_SUGANG_CODE    IN TBL_SUGANG.SUGANG_CODE%TYPE)
IS
    E_SUGANG_CODE   TBL_SUGANG.SUGANG_CODE%TYPE;
    SUGANG_DEFINE_ERROR EXCEPTION;  -- 해당 코드가 없을때 

BEGIN
    -- 수강코드 체크
    SELECT NVL((SELECT SUGANG_CODE FROM TBL_SUGANG WHERE SUGANG_CODE=V_SUGANG_CODE),'0')
           INTO E_SUGANG_CODE 
    FROM DUAL;

    IF (E_SUGANG_CODE = '0')
        THEN RAISE SUGANG_DEFINE_ERROR;
    END IF;


    -- DELETE 문
    DELETE
    FROM TBL_SUGANG
    WHERE SUGANG_CODE = V_SUGANG_CODE;


    -- 예외처리
    EXCEPTION
        WHEN SUGANG_DEFINE_ERROR
        THEN RAISE_APPLICATION_ERROR(-20903,'수강코드가 존재하지 않습니다. 다시입력하세요.');
            ROLLBACK;
        WHEN OTHERS
        THEN ROLLBACK;


    -- 커밋
    COMMIT;
END;






-- PRC_SUGANG_INSERT		(수강신청)
create or replace PROCEDURE PRC_SUGANG_INSERT
( V_OPENCOU_CODE    IN TBL_SUGANG.OPENCOU_CODE%TYPE
, V_STD_CODE        IN TBL_SUGANG.STD_CODE%TYPE
)
IS
   V_SUGANG_CODE TBL_SUGANG.SUGANG_CODE%TYPE; 

   -- 과정시작일 담을 변수
   V_OPENCOU_START TBL_OPENCOU.OPENCOU_START%TYPE;

   -- 중복신청을 체크할 커서
   CURSOR CUR_SUGANG_CHECK          
   IS
   SELECT OPENCOU_CODE
   FROM TBL_SUGANG
   WHERE STD_CODE = V_STD_CODE;

   --커서에 쓰일 변수
   V_OPENCOU_CODE_TEMP  TBL_SUGANG.OPENCOU_CODE%TYPE;


   SUGANG_DEFINE_ERROR1 EXCEPTION;  -- 수강신청일자가 과정시작한 후
   SUGANG_DEFINE_ERROR2 EXCEPTION;  -- 과정중복신청

BEGIN
    -- 과정 시작일 담기    
    SELECT OPENCOU_START INTO V_OPENCOU_START
    FROM TBL_OPENCOU
    WHERE OPENCOU_CODE = V_OPENCOU_CODE;

    -- 수강신청일이 과정시작일 이후라면 2번에러 발생
    -- 과정시작당일에 수강신청할수없음
    IF (V_OPENCOU_START <= SYSDATE)
        THEN RAISE SUGANG_DEFINE_ERROR1;
    END IF;

    -- 과정 중복신청을 잡을 커서 오픈
    OPEN CUR_SUGANG_CHECK;
        LOOP
            FETCH CUR_SUGANG_CHECK INTO V_OPENCOU_CODE_TEMP;

            -- 꺼낼데이터가 없을때 빠져나옴
            EXIT WHEN CUR_SUGANG_CHECK%NOTFOUND;

            -- 과정이 중복일때 2번에러 발생
            IF(V_OPENCOU_CODE_TEMP = V_OPENCOU_CODE)
                THEN RAISE SUGANG_DEFINE_ERROR2;
            END IF;
        END LOOP;

    -- 커서 클로즈
    CLOSE CUR_SUGANG_CHECK;



    -- 수강신청코드 생성
    V_SUGANG_CODE := TO_CHAR(SUG_CODE_SEQ.NEXTVAL);
    V_SUGANG_CODE := 'SUG' || LPAD(V_SUGANG_CODE,3,0);

    -- INSERT문
    INSERT INTO TBL_SUGANG (SUGANG_CODE, OPENCOU_CODE, STD_CODE, SUGANG_DATE)
    VALUES (V_SUGANG_CODE, V_OPENCOU_CODE, V_STD_CODE, SYSDATE);



    -- 예외처리
    EXCEPTION
        WHEN SUGANG_DEFINE_ERROR1
        THEN RAISE_APPLICATION_ERROR(-20900, '이미 시작한 과정입니다.');
        ROLLBACK;
        WHEN SUGANG_DEFINE_ERROR2
        THEN RAISE_APPLICATION_ERROR(-20901, '이미 신청한 과정입니다.');
        ROLLBACK;


    -- 커밋
    COMMIT;

END;


--> 총합 38개
/*
================================================================================
                  ■■■■■■   VIEW   ■■■■■■
================================================================================
*/
--○ 개설과정
-- VIEW_COURSE_INFO
--> 과정이름, 강의실, 과목명, 과목시작일, 과목종료일, 교재명, 교수자명
CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_COURSE_INFO" ("과정이름", "강의실", "과목명", "과목시작일", "과목종료일", "교재명", "교수자명") AS 
  SELECT COU.COURSE_NAME "과정이름"
     , CLA.CLASS_NAME "강의실"
     , SB.SUB_NAME "과목명"
     , OSB.OPENSUB_START "과목시작일"
     , OSB.OPENSUB_END "과목종료일"
     , BO.BOOK_NAME "교재명"
     , PR.PROF_NAME "교수자명"
FROM TBL_OPENCOU OPC JOIN TBL_COURSE COU
    ON OPC.COURSE_CODE = COU.COURSE_CODE
    JOIN TBL_CLASS CLA
    ON CLA.CLASS_CODE = OPC.CLASS_CODE
    JOIN TBL_OPENSUB OSB
    ON OPC.OPENCOU_CODE = OSB.OPENCOU_CODE
    JOIN TBL_PROF PR
    ON OSB.PROF_CODE = PR.PROF_CODE
    JOIN TBL_BOOK BO
    ON OSB.BOOK_CODE = BO.BOOK_CODE
    JOIN TBL_SUB SB
    ON SB.SUB_CODE = OSB.SUB_CODE;






--○ 제적된 학생의 로그인 정보
-- VIEW_OUT_IDPW
--> 학번, 학생PW
CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_OUT_IDPW" ("학번", "학생PW") AS 
  SELECT STD.STD_CODE "학번", STD.STD_PW "학생PW" 
FROM TBL_OUT OUT
        JOIN TBL_SUGANG SG
        ON OUT.SUGANG_CODE = SG.SUGANG_CODE
                JOIN TBL_STD STD
                ON SG.STD_CODE = STD.STD_CODE;






--○ 관리자의 교수정보 조회
-- VIEW_PROF_INFO
--> 교수이름, 배정과목, 과목시작일, 과목 종료일, 교재명, 강의실, 강의진행여부
CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_PROF_INFO" ("교수이름", "배정과목", "과목시작일", "과목종료일", "교재명", "강의실", "강의진행여부") AS 
  SELECT TP.PROF_NAME"교수이름"
    ,  TS.SUB_NAME "배정과목"
    ,  TOS.OPENSUB_START "과목시작일"
    ,  TOS.OPENSUB_END "과목종료일"
    ,  TB.BOOK_NAME "교재명"
    ,  TC.CLASS_NAME "강의실"
    ,  CASE WHEN SYSDATE BETWEEN TOS.OPENSUB_START AND TOS.OPENSUB_END 
            THEN '강의중'
            WHEN SYSDATE < TOS.OPENSUB_START
            THEN '강의예정'
       ELSE '강의종료'
       END "강의진행여부"

FROM TBL_PROF TP , TBL_SUB TS, TBL_OPENSUB TOS, TBL_OPENCOU TOC, TBL_BOOK TB, TBL_CLASS TC
WHERE TOS.PROF_CODE = TP.PROF_CODE(+)
  AND TOS.SUB_CODE = TS.SUB_CODE(+)
  AND TOS.BOOK_CODE = TB.BOOK_CODE(+)
  AND TOS.OPENCOU_CODE = TOC.OPENCOU_CODE(+)
  AND TOC.CLASS_CODE = TC.CLASS_CODE(+)
ORDER BY 1;







--○ 교수자가 입력한 성적의 정보
-- VIEW_PROF_SCORE_INFO
--> 과목명, 과목기간, 교재명, 학생명, 출결, 필기, 실기, 총점, 등수 , 중도탈락여부
CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_PROF_SCORE_INFO" ("과목명", "과목기간", "교재명", "학생명", "출결", "필기", "실기", "총점", "등수", "중도탈락여부") AS 
  SELECT T.과목명, T.과목기간, T.교재명, T.학생명, T.출결, T.필기, T.실기, T.총점
, RANK() OVER(PARTITION BY T.개설과목코드 ORDER BY T.총점 DESC) "등수"
, T.중도탈락여부
FROM (
        SELECT SB.SUB_NAME "과목명"
        , OS.OPENSUB_START || ' ~ ' || OS.OPENSUB_END "과목기간"
        , BK.BOOK_NAME "교재명"
        , SD.STD_NAME "학생명"
        , SC.SCO_ATTEND "출결"
        , SC.SCO_WRITE "필기"
        , SC.SCO_PRAC "실기"
        , FN_TOTAL_SCORE(SC.SCO_CODE, OS.OPENSUB_CODE)"총점"
        , OS.OPENSUB_CODE "개설과목코드"
        , CASE WHEN SG.SUGANG_CODE = OT.SUGANG_CODE
               THEN '○'
               ELSE 'Ⅹ'
                END "중도탈락여부"
        FROM TBL_OPENSUB OS
        JOIN TBL_PROF PR
          ON OS.PROF_CODE = PR.PROF_CODE
        JOIN TBL_SUB SB
          ON OS.SUB_CODE = SB.SUB_CODE
        JOIN TBL_BOOK BK
          ON OS.BOOK_CODE = BK.BOOK_CODE
        JOIN TBL_SCO SC
          ON OS.OPENSUB_CODE = SC.OPENSUB_CODE
        JOIN TBL_SUGANG SG
          ON SC.SUGANG_CODE = SG.SUGANG_CODE
        JOIN TBL_STD SD
          ON SG.STD_CODE = SD.STD_CODE
        LEFT JOIN TBL_OUT OT
               ON SG.SUGANG_CODE = OT.SUGANG_CODE

) T;






--○ 교수자가 성적을 입력할시 조회되는 학생의 정보
-- VIEW_PROF_STD_INFO
--> 교수명, 과목명, 과목시작일, 과목종료일, 학생명, 수강코드
CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_PROF_STD_INFO" ("교수명", "과목명", "과목시작일", "과목종료일", "학생명", "수강코드") AS 
  SELECT TP.PROF_NAME "교수명" , TS.SUB_NAME "과목명" 
    ,  OPS.OPENSUB_START "과목시작일", OPS.OPENSUB_END "과목종료일"
    ,  SD.STD_NAME "학생명", SG.SUGANG_CODE "수강코드"
    
FROM TBL_OPENSUB OPS, TBL_SUB TS, TBL_SUGANG SG, TBL_STD SD
    ,TBL_OPENCOU OPC, TBL_PROF TP, TBL_OUT TOT
WHERE OPS.OPENCOU_CODE = OPC.OPENCOU_CODE(+)
  AND OPC.OPENCOU_CODE = SG.OPENCOU_CODE(+)    
  AND SG.STD_CODE  = SD.STD_CODE (+)       
  AND OPS.SUB_CODE = TS.SUB_CODE(+)      
  AND OPS.PROF_CODE = TP.PROF_CODE(+)        
  AND SG.SUGANG_CODE = TOT.SUGANG_CODE(+) 
  -- 중도탈락 제외
  AND TOT.OUT_CODE IS NULL
  -- 강의중인것만 출력
  AND OPS.OPENSUB_START <= SYSDATE 
  -- 강의 종료 후 7일일 이내만 성적처리 가능
  AND SYSDATE < OPS.OPENSUB_END+7
ORDER BY 2;






--○ 관리자가 학생의 정보 조회
-- VIEW_STD_INFO
--> 학생이름, 과정명, 수강과목, 수강과목 총점
  CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_STD_INFO" ("학생이름", "과정명", "수강과목", "수강과목 총점") AS 
  SELECT DISTINCT ST.STD_NAME "학생이름"
    ,  CO.COURSE_NAME "과정명"
    ,  SUB.SUB_NAME "수강과목"
    ,  CASE WHEN OUT.SUGANG_CODE IS NOT NULL THEN '중도탈락, 성적 조회 불가.'
            WHEN SCO.SUGANG_CODE IS NULL THEN '성적 입력 이전입니다.'
            ELSE TO_CHAR(SCO.SCO_ATTEND + SCO.SCO_WRITE + SCO.SCO_PRAC)
       END "수강과목총점"
FROM TBL_STD ST, TBL_SUGANG SG, TBL_OPENCOU OC, TBL_COURSE CO, TBL_OPENSUB OS, TBL_SUB SUB, TBL_SCO SCO, TBL_OUT OUT
WHERE SG.STD_CODE= ST.STD_CODE(+)
  AND SG.OPENCOU_CODE = OC.OPENCOU_CODE(+)
  AND OC.COURSE_CODE = CO.COURSE_CODE(+)
  AND OC.OPENCOU_CODE = OS.OPENCOU_CODE(+)
  AND OS.SUB_CODE = SUB.SUB_CODE(+)
  AND SG.SUGANG_CODE = SCO.SUGANG_CODE(+)
  AND SG.SUGANG_CODE = OUT.SUGANG_CODE(+)
ORDER BY 학생이름, 과정명, 수강과목;





--○ 학생이 성적을 조회할 시 확인할 수 있는 정보
-- VIEW_STD_SCO
--> 학생이름, 과정명, 과목명, 과목시작일, 과목종료일, 교재명, 출결, 필기, 실기, 총합, 등수
  CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_STD_SCO" ("학생이름", "과정명", "과목명", "과목시작일", "과목종료일", "교재명", "출결", "필기", "실기", "총합", "등수") AS 
  SELECT STD.STD_NAME "학생이름", COU.COURSE_NAME "과정명", SUB.SUB_NAME "과목명", OS.OPENSUB_START "과목시작일"
, OS.OPENSUB_END "과목종료일", BK.BOOK_NAME "교재명", SCO.SCO_ATTEND "출결", SCO.SCO_WRITE "필기"
, SCO.SCO_PRAC "실기", SCO.SCO_ATTEND + SCO.SCO_WRITE + SCO.SCO_PRAC "총합" 
, RANK() OVER (PARTITION BY OS.OPENSUB_CODE ORDER BY SCO.SCO_ATTEND + SCO.SCO_WRITE + SCO.SCO_PRAC DESC) "등수"
FROM TBL_SCO SCO 
     JOIN TBL_OPENSUB OS
     ON SCO.OPENSUB_CODE = OS.OPENSUB_CODE
        JOIN TBL_SUB SUB
        ON OS.SUB_CODE = SUB.SUB_CODE
            JOIN TBL_BOOK BK
            ON OS.BOOK_CODE = BK.BOOK_CODE
                JOIN TBL_SUGANG SG
                ON SCO.SUGANG_CODE = SG.SUGANG_CODE
                    JOIN TBL_STD STD
                    ON SG.STD_CODE = STD.STD_CODE
                        JOIN TBL_OPENCOU OC
                        ON SG.OPENCOU_CODE = OC.OPENCOU_CODE
                            JOIN TBL_COURSE COU
                            ON OC.COURSE_CODE = COU.COURSE_CODE
ORDER BY 학생이름;







--○ 과정정보를 확인
-- VIEW_SUB_INFO
--> 과정명, 강의실명, 과목명, 과목명, 과목시작일, 과목종료일, 교재명, 교수이름
CREATE OR REPLACE FORCE VIEW "FOURTH"."VIEW_SUB_INFO" ("과정명", "강의실명", "과목명", "과목시작일", "과목종료일", "교재명", "교수이름") AS 
  SELECT CO.COURSE_NAME "과정명"
, CL.CLASS_NAME "강의실명"
, SB.SUB_NAME "과목명"
, OS.OPENSUB_START "과목시작일"
, OS.OPENSUB_END "과목종료일"
, BK.BOOK_NAME "교재명"
, PR.PROF_NAME "교수이름"
FROM TBL_OPENSUB OS
JOIN TBL_OPENCOU OC
ON OS.OPENCOU_CODE = OC.OPENCOU_CODE
JOIN TBL_CLASS CL
ON OC.CLASS_CODE = CL.CLASS_CODE
JOIN TBL_COURSE CO
ON OC.COURSE_CODE = CO.COURSE_CODE
JOIN TBL_SUB SB
ON OS.SUB_CODE = SB.SUB_CODE
JOIN TBL_BOOK BK
ON OS.BOOK_CODE = BK.BOOK_CODE
JOIN TBL_PROF PR
ON OS.PROF_CODE = PR.PROF_CODE;






--> 총합 8개
-------------------------------------------------------------------------------------------

/*
■■■■■■   함수   ■■■■■■
*/

--○ 학생 성적 총점 계산 함수
-- FN_TOTAL_SCORE 
create or replace FUNCTION FN_TOTAL_SCORE
( V_SCO_CODE     IN TBL_SCO.SCO_CODE%TYPE       -- 성적코드
, V_OPENSUB_CODE IN TBL_OPENSUB.OPENSUB_CODE%TYPE --개설과목코드
)
    RETURN NUMBER
IS
    RESULT NUMBER;

    V_ATTEND_PERC TBL_OPENSUB.OPENSUB_ATTEND%TYPE;
    V_WRITE_PERC TBL_OPENSUB.OPENSUB_WRITE%TYPE;
    V_PRAC_PERC TBL_OPENSUB.OPENSUB_PRAC%TYPE;

    V_ATTEND_SCORE TBL_SCO.SCO_ATTEND%TYPE;
    V_WRITE_SCORE TBL_SCO.SCO_WRITE%TYPE;
    V_PRAC_SCORE TBL_SCO.SCO_PRAC%TYPE;

BEGIN
    -- 해당 수강과목코드의 배점 가져오기
    SELECT NVL(OPENSUB_ATTEND, 0), NVL(OPENSUB_WRITE, 0), NVL(OPENSUB_PRAC, 0)
    INTO V_ATTEND_PERC, V_WRITE_PERC, V_PRAC_PERC
    FROM TBL_OPENSUB
    WHERE OPENSUB_CODE = V_OPENSUB_CODE;

    -- 해당 성적코드로 성적 가져오기
    SELECT NVL(SCO_ATTEND, 0), NVL(SCO_WRITE, 0), NVL(SCO_PRAC, 0)
    INTO V_ATTEND_SCORE, V_WRITE_SCORE, V_PRAC_SCORE
    FROM TBL_SCO
    WHERE SCO_CODE = V_SCO_CODE;


    RESULT := (V_ATTEND_PERC * V_ATTEND_SCORE + V_WRITE_PERC * V_WRITE_SCORE + V_PRAC_PERC * V_PRAC_SCORE)/100;
    RETURN RESULT;
END;






--> 총합 1개
/*
================================================================================
                  ■■■■■■   트리거   ■■■■■■
================================================================================
*/

--○ 과목을 삭제할 시 이미 과정으로 개설된 과목의 삭제전 검증
-- TRG_SUB_DELETE1
create or replace TRIGGER TRG_SUB_DELETE1
    BEFORE
    DELETE ON TBL_SUB
    FOR EACH ROW
BEGIN
    DELETE 
    FROM TBL_OPENSUB
    WHERE SUB_CODE = :OLD.SUB_CODE;
END;






--○ 강의실을 삭제할 시 이미 과정으로 포함된 강의실의 삭제전 검증
-- TRG_CLASS_DELETE1
create or replace TRIGGER TRG_CLASS_DELETE1
        BEFORE
        DELETE ON TBL_CLASS
        FOR EACH ROW
BEGIN

    DELETE 
    FROM TBL_OPENCOU
    WHERE CLASS_CODE = :OLD.CLASS_CODE;

END;







--○ 과정을 삭제하기 전 개설 과정에 이미 포함된 강의실의 삭제전 검증
-- TRG_COURSE_DELETE1
create or replace TRIGGER TRG_COURSE_DELETE1
        BEFORE
        DELETE ON TBL_COURSE
        FOR EACH ROW
BEGIN

    DELETE 
    FROM TBL_OPENCOU
    WHERE COURSE_CODE = :OLD.COURSE_CODE;

END;







--○ 개설 과정을 삭제하기 전 수강신청이 이루어진 과정인지 삭제전 검증
-- TRG_COURSE_DELETE2
create or replace TRIGGER TRG_COURSE_DELETE2
        BEFORE
        DELETE ON TBL_OPENCOU
        FOR EACH ROW
BEGIN

    DELETE 
    FROM TBL_SUGANG
    WHERE OPENCOU_CODE = :OLD.OPENCOU_CODE;

END;







--○ 개설 과정을 삭제하기 전 개설 과목에 과정이 배정되어 있는지 삭제전 검증
-- TRG_COURSE_DELETE3 
create or replace TRIGGER TRG_COURSE_DELETE3
        BEFORE
        DELETE ON TBL_OPENCOU
        FOR EACH ROW
BEGIN

    DELETE 
    FROM TBL_OPENSUB
    WHERE OPENCOU_CODE = :OLD.OPENCOU_CODE;

END;







--> 총합 5개

/*
================================================================================
                  ■■■■■■   시퀀스   ■■■■■■
================================================================================
*/
--○ 강의실 코드 시퀀스
-- SEQ_CLASS
CREATE SEQUENCE  "FOURTH"."SEQ_CLASS"  
MINVALUE 1 MAXVALUE 9999999999999999999999999999 
INCREMENT BY 1 
START WITH 41 
CACHE 20 
ORDER  NOCYCLE ;







--○ 교수코드 시퀀스
-- PROF_CODE_SEQ
CREATE SEQUENCE  "FOURTH"."PROF_CODE_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 64 
CACHE 20 
NOORDER  NOCYCLE ;







--○ 과정 코드 시퀀스
-- SEQ_COURSE
CREATE SEQUENCE  "FOURTH"."SEQ_COURSE"  
MINVALUE 1 
MAXVALUE 9999999999999999999999999999 
INCREMENT BY 1 
START WITH 41 
CACHE 20 
ORDER  NOCYCLE ;







--○ 개설과정 코드 시퀀스
-- SEQ_OPENCOU
CREATE SEQUENCE  "FOURTH"."SEQ_OPENCOU"  
MINVALUE 1 
MAXVALUE 9999999999999999999999999999 
INCREMENT BY 1 
START WITH 41 
CACHE 20 
ORDER  NOCYCLE ;







--○ 성적코드 시퀀스
-- SEQ_SCO
CREATE SEQUENCE  "FOURTH"."SEQ_SCO"  
MINVALUE 1 
MAXVALUE 9999999999999999999999999999 
INCREMENT BY 1 
START WITH 21 
CACHE 20 
NOORDER  NOCYCLE ;







--○ 학생코드 시퀀스
-- STD_SEQ
CREATE SEQUENCE  "FOURTH"."STD_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 10 
NOCACHE  
NOORDER  NOCYCLE ;







--○ 수강코드 시퀀스
-- SUG_CODE_SEQ
CREATE SEQUENCE  "FOURTH"."SUG_CODE_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 41 
CACHE 20 
NOORDER  NOCYCLE ;







--○ 관리자 코드 시퀀스
-- TBL_ADMIN_SEQ
CREATE SEQUENCE  "FOURTH"."TBL_ADMIN_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 4 
NOCACHE  
NOORDER  NOCYCLE ;







--○ 교재코드 시퀀스
-- TBL_BOOK_SEQ
CREATE SEQUENCE  "FOURTH"."TBL_BOOK_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 12 
NOCACHE  
NOORDER  NOCYCLE ;







--○ 개설과목코드 시퀀스
-- TBL_OPENSUB_SEQ
CREATE SEQUENCE  "FOURTH"."TBL_OPENSUB_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 9 
NOCACHE  
NOORDER  NOCYCLE ;







--○ 중도탈락사유코드 시퀀스
-- TBL_OUT_REASON_SEQ
CREATE SEQUENCE  "FOURTH"."TBL_OUT_REASON_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 3 
NOCACHE  
NOORDER  NOCYCLE ;







--○ 중도탈락 코드 시퀀스
-- TBL_OUT_SEQ
CREATE SEQUENCE  "FOURTH"."TBL_OUT_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 44 
NOCACHE  
NOORDER  NOCYCLE ;







--○ 과목코드 시퀀스
-- TBL_SUB_SEQ
CREATE SEQUENCE  "FOURTH"."TBL_SUB_SEQ"  
MINVALUE 1 
MAXVALUE 999 
INCREMENT BY 1 
START WITH 11 
NOCACHE  
NOORDER  NOCYCLE ;

--> 13개


